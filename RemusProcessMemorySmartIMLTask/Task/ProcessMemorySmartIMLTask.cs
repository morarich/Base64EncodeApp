using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Xml;
using System.Xml.Linq;
using System.Data;
using System.Data.SqlClient;
using System.ComponentModel;
using System.Reflection;
using System.IO.Compression;
using System.Net.Mail;
using System.Text.RegularExpressions;
using DataServicesGlobalReportingDataAccess.DataLayer;
using DataServicesGlobalReportingDataLogger;
using ConsoleSpinner;


namespace RemusProcessMemorySmartIMLTask
{
    /// <summary>
    /// This class is the <see cref="ProcessFirmwareTask" />, <see cref="ProcessFirmwareTask" /> which contains the methods to process ReMUS xxxxxx Test Output Files.
    /// </summary>
    /// <remarks>
    /// Author: Jason Hawthorne
    /// <para/>Created:  5/10/2015
    /// <para/>Modified By: Richard Morales
    /// <para/>Date: 05-14-2019 
    /// <para/>Comment: Developed to parse SmartMemoryPPR JSON file IML_LOG.JSON
    /// </remarks> 
    /// <seealso cref="System.IDisposable" />
    public class ProcessMemorySmartIMLTask //: IDisposable
    {
        #region Design Pattern Constants

        /// <summary>
        /// The ISO 8601 date format map
        /// </summary>
        const string Iso8601DateFormatMap = "yyyy-MM-ddTHH:mm:ss.fffffff";

        #endregion Design Pattern Constants

        #region Design Patttern Variables

        /// <summary>
        /// The tof
        /// </summary>
        //TOFProcessing TOF = new TOFProcessing();

        /// <summary>
        /// The logger
        /// </summary>
        DataLogger Logger = new DataLogger();

        /// <summary>
        /// The configuration
        /// </summary>
       public TaskConfig  Config = new TaskConfig();

        /// <summary>
        /// The console spiner
        /// </summary>
        Spinner ConsoleSpiner = new Spinner();

        /// <summary>
        /// The Command Line Options
        /// </summary>
        CommandLineOptions Options = new CommandLineOptions();

        /// <summary>
        /// The deployment settingson
        /// </summary>
        /// <summary>
        /// The data access layer
        /// </summary>
        DataAccessFacade DataAccess = new DataAccessFacade();
 
        /// <summary>
        /// The task name
        /// </summary>
        String TaskName = Path.GetFileName(Environment.GetCommandLineArgs()[0]);

        /// <summary>
        /// The location the task is executing from
        /// </summary>
        String TaskLocation = System.IO.Path.GetDirectoryName(System.Reflection.Assembly.GetEntryAssembly().Location);
        enum EventType {
            OnError,
            OnTaskFailed,
            CustomInformation,
            OnPostExecute,
            OnPreExecute,
            OnInformation,
            OnProgress,
            OnWarning,
                        }

        #endregion Design Patttern Variables

        #region Task Process Variables

        string TaskPurpose = "This is a Data Services ReMUS Task for processing Smart PPr IML JSON files generated by the ReMUS Test Executive.\r\n" +
                             "The associated JSON file is the configuration file for automated processing of these TOFs.\r\n\r\n";

        DataTable TestOutputFiles = new DataTable();

        ScanParameter ScanParms = new ScanParameter();

        List<FirmwaredataObject> firmwares = new List<FirmwaredataObject>();

        DataTable dtProKeyAndGeoKey = new DataTable();

        //readonly string TofName = @"DataCollection.zip|systeminfo.xml";
        //readonly string TestSystem = @"ReMUS";

        #endregion Task Process Variables

        #region Design Pattern 

        #region Main Startup Methods

        /// <summary>
        /// Runs the specified arguments.
        /// </summary>
        /// <param name="args">The arguments.</param>
        public void Run(string[] args)
        {
            //Enable log writing for alla events. Tese values will set when the confirutation file loads. 
            // Set Loging
            Logger.LogErrors = true;
            Logger.LogFailureAudits = true;
            Logger.LogInformation = true;
            Logger.LogSuccessAudits = true;
            Logger.LogWarnings = true;

            if (ProcessArguments(args))
            {
                ShowProgress(TaskName + " task has started...");

                // Log to NextGenTestServices 
                Logger.LogEvent(System.Diagnostics.EventLogEntryType.Information,
                   TaskName + " task has started.",
                    (int)ApplicationEventID.TOFTaskStart,
                    (short)EventCategoryID.Tasks);


                if (LoadTaskSettings())
                {
                    Spinner.Start();
                   
                    StartProcess();

                    Spinner.Stop();
                }

                ShowProgress(TaskName + " task has finished.");

                // Log to NextGenTestServices 
                Logger.LogEvent(System.Diagnostics.EventLogEntryType.Information,
                    TaskName + " task has finished.",
                    (int)ApplicationEventID.TOFTaskComplete,
                    (short)EventCategoryID.Tasks);

            }
        }

        /// <summary>
        /// Processes the arguments.
        /// </summary>
        /// <param name="args">The arguments.</param>
        private bool ProcessArguments(string[] args)
        {
            bool result = true;
            var options = String.Empty;
            var version = System.Reflection.Assembly.GetExecutingAssembly().GetName().Version;

            for (int i = 0; i < args.Length; i++)
            {
                if (args[i].ToLower() == "-d")
                {
                    Options.ShowDetail = true;
                    options = options + args[i] + " ";
                }
                if (args[i].ToLower() == "-i")
                {
                    Options.Interactive = true;
                    options = options + args[i] + " ";
                }
                if (args[i].ToLower() == "-h")
                {
                    ShowHelp(args);
                    return false;
                }
                if (args[i].ToLower().Contains("-from="))
                {
                    string[] s = args[i].Split('=');
                    Options.ManualFromDate = s[1];
                    //Need to add the double quote around the DateTime value to match the commad line input
                    string value = args[i].Insert(5, "\"");
                    options = options + value.Insert(value.Length, "\"") + " ";
                }
                if (args[i].ToLower().Contains("-to="))
                {
                    string[] s = args[i].Split('=');
                    Options.ManualToDate = s[1];
                    //Need to add the double quote around the DateTime value to match the commad line input
                    string value = args[i].Insert(3, "\"");
                    options = options + value.Insert(value.Length, "\"") + " ";
                }
                if (args[i].ToLower() == "-m")
                {
                    Options.ManualDateRangeProcessing = true;
                    options = options + args[i] + " ";
                }
            }

            Console.WriteLine("Starting {0} \r\n\tOptions {1} \r\n\tVersion {2} \r\n", TaskName, options, version.ToString());
            //Evaluate Options
            if (Options.ManualDateRangeProcessing)
            {
                // Check for From and To
                if (Options.ManualFromDate != null)
                {
                    if (Options.ManualFromDate.Trim().Length == 0)
                    {
                        ShowProgress(@"-m Option requires a valid From Date value. See help for more information.", 1);
                        Options.ManualDateRangeProcessing = false;
                    }
                }
                else
                {
                    ShowProgress(@"-m Option requires a valid From Date value. See help for more information.", 1);
                    Options.ManualDateRangeProcessing = false;
                }

                if (Options.ManualToDate != null)
                {
                    if (Options.ManualToDate.Trim().Length == 0)
                    {
                        ShowProgress(@"-m Option requires a valid To Date value. See help for more information.", 1);
                        Options.ManualDateRangeProcessing = false;
                    }
                }
                else
                {
                    ShowProgress(@"-m Option requires a valid To Date value. See help for more information.", 1);
                    Options.ManualDateRangeProcessing = false;
                }

                // Validate From and To
                if (!IsValidDate(Options.ManualFromDate))
                {
                    ShowProgress("From Date is not a valid DateTime value.", 1);
                    Options.ManualDateRangeProcessing = false;
                }

                if (!IsValidDate(Options.ManualFromDate))
                {
                    ShowProgress("From Date is not a valid DateTime value.", 1);
                    Options.ManualDateRangeProcessing = false;
                }
                result = Options.ManualDateRangeProcessing;
            }
            else
            {
                result = true;
            }
            return result;
        }

        /// <summary>
        /// Shows the help.
        /// </summary>
        /// <param name="args">The arguments.</param>
        private void ShowHelp(string[] args)
        {
            Console.WriteLine("{1} running from {0}.", TaskLocation,
                TaskName);
            Console.WriteLine("");
            Console.Write(TaskPurpose);
            Console.WriteLine("Command Line Options:\r\n");
            Console.WriteLine("-h : Displays this help information.\r\n");
            Console.WriteLine("-d : Show details during processing.  This option will pause the task at the end so is should not be set as a default option in production.\r\n");
            Console.WriteLine("-i : Show details during process as well requireing user input to proceed to the next step. This option should not be set as a default option in production.\r\n");
            Console.WriteLine("-f : This option requires a path to a list of files for processing.  ex. -f|c:\temp\filelist.txt \r\n.This option will override automated processing to allow processing of a specific set of files and is not limited to the configuration property 'MaxFilesToProcess'.\r\n");
            Console.WriteLine("press any key to exit...");
            Console.ReadKey();
        }

        /// <summary>
        /// Starts the process.
        /// </summary>
        private void StartProcess()
        {
            ProcessTofReferenceData();
        }

        #endregion Main Startup Methods

        #region Helper Methods

        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        ///   <c>true</c> if [is valid date] [the specified value]; otherwise, <c>false</c>.
        /// </returns>
        private bool IsValidDate(string value)
        {
            DateTime dateValue;

            if (DateTime.TryParse(value, out dateValue))
                return true;
            else
                return false;
        }

        /// <summary>
        /// Shows the progress.
        /// </summary>
        /// <param name="waitForKeyPress">if set to <c>true</c> [wait for key press].</param>
        /// <param name="output">The output.</param>
        private void ShowProgress(string output, int indentLevel = 0)
        {
            string indent = "";
            for (int idx = 0; idx < indentLevel; idx++)
            {
                indent = indent + "\t";
            }

            if (Options.Interactive || Options.ShowDetail)
            {
                if (Options.Interactive)
                {
                    Console.WriteLine(indent + output + "\r\nPress Any Key to continue...\r\n");
                    Console.ReadKey();
                }
                else
                {
                    Console.WriteLine(indent + output + "\r\n");
                }
            }
        }

        /// <summary>
        /// Loads the service settings.
        /// To update the service settings you use a windows application for managing Data Services NextGen Services that was installed wtih this service.
        /// </summary>
        public bool LoadTaskSettings()
        {
            // Note: Not using a 'Using' statement with the stream reader  so we can process any exception caught
            // The managed resource is disposed of in the finally block.
            // References: https://msdn.microsoft.com/en-us/library/aa355056%28v=vs.110%29.aspx
            // https://msdn.microsoft.com/en-us/library/yh598w02.aspx
            // https://msdn.microsoft.com/en-us/library/ms182334.aspx

            StreamReader file = null;
            bool result = false;

            try
            {
                ShowProgress("Loading configuration file: " + TaskLocation + "\\" + Path.GetFileNameWithoutExtension(TaskName) + ".json");
                // Load the seettings
                file = File.OpenText(TaskLocation + "\\" + Path.GetFileNameWithoutExtension(TaskName) + ".json");

                Console.WriteLine("Loading setting from JSON config file: {0}", TaskLocation + @"\" + Path.GetFileNameWithoutExtension(TaskName) + ".json");

                JsonSerializer serializer = new JsonSerializer();
                Config = (TaskConfig)serializer.Deserialize(file, typeof(TaskConfig));
                
                // Set Loging based on config file
                Logger.LogErrors = Config.LogErrors;
                Logger.LogFailureAudits = Config.LogFailureAudits;
                Logger.LogInformation = Config.LogInformation; ;
                Logger.LogSuccessAudits = Config.LogSuccessAudits;
                Logger.LogWarnings = Config.LogWarnings;

                result = true;
            }
            catch (Exception ex)
            {
                ShowProgress(TaskName + " could not start due to an error accessing the json configuration file: " + TaskLocation + "\\" + Path.GetFileNameWithoutExtension(TaskName) + ".json");
                // Log to NextGenTestServices 
                Logger.LogEvent(System.Diagnostics.EventLogEntryType.Error,
                     TaskName + " could not start due to an error accessing the json configuration file: " + TaskLocation + @"\" + Path.GetFileNameWithoutExtension(TaskName) + ".json" + "\r\n" + ex.ToString(),
                   (int)ApplicationEventID.TOFTaskError,  //NOTE YOU NEED TO ADD ADDITIONAL EVENTS TO THE DATA LOGGER CLASS
                   (short)EventCategoryID.Tasks);

                // Log to Management database Event Log
                LogEvent(EventType.OnError.ToString()
                    , "LoadTaskSettings()"
                    , TaskName + " could not start due to an error accessing the json configuration file: " + TaskLocation + @"\" + Path.GetFileNameWithoutExtension(TaskName) + ".json"
                    , ex.ToString());
            }
            finally
            {
                if (file != null)
                {
                    file.Dispose();
                }
            }

            return result;
        }

        #endregion Helper Methods

        #region Database Methods

        /// <summary>
        /// Creates the scan log.
        /// </summary>
        private void CreateScanLog()
        {
            // Note: Not using a 'Using' statement with SqlCommand so we can process any exception caught at the DataLayer
            // The managed resource is disposed of in the finally block.
            // References: https://msdn.microsoft.com/en-us/library/aa355056%28v=vs.110%29.aspx
            // https://msdn.microsoft.com/en-us/library/yh598w02.aspx
            // https://msdn.microsoft.com/en-us/library/ms182334.aspx
            SqlCommand sqlCmd = new SqlCommand();

            try
            {
                //For Debugging, the TaskName will contain vshost.exe and will not be found. so we check for vshost, and rename.
                string taskName = Path.GetFileNameWithoutExtension(TaskName);
                if (taskName.Contains(".vshost"))
                {
                    taskName = taskName.Replace(".vshost", "");
                }
                sqlCmd.CommandType = CommandType.StoredProcedure;
                if (Config.IsProduction)
                {
                    sqlCmd.CommandText = "[DataServicesManagement].[dbo].[ScanLogCreate]";
                }
                else
                {
                    sqlCmd.CommandText = "[DataServicesManagementLab].[dbo].[ScanLogCreate]";
                }

                sqlCmd.Parameters.Add("@PackageName", SqlDbType.VarChar).Value = taskName;
                sqlCmd.Parameters.Add("@ScanLogStartDate", SqlDbType.DateTime).Value = DateTime.UtcNow;
                sqlCmd.Parameters.Add("@ScanLogEndDate", SqlDbType.DateTime).Value = DBNull.Value;
                sqlCmd.Parameters.Add("@ScanLogFromDate", SqlDbType.DateTime).Value = ScanParms.ScanFrom;
                sqlCmd.Parameters.Add("@ScanLogToDate", SqlDbType.DateTime).Value = ScanParms.ScanTo;
                sqlCmd.Parameters.Add("@ScanLogDescription", SqlDbType.VarChar).Value = TaskName + " starting...";
                sqlCmd.Parameters.Add("@SuccessFlag", SqlDbType.Bit).Value = 0;
                sqlCmd.Parameters.Add("@FromRecordId", SqlDbType.Int).Value = DBNull.Value;
                sqlCmd.Parameters.Add("@ToRecordId", SqlDbType.Int).Value = DBNull.Value;
                sqlCmd.Parameters.Add("@PackageVersion", SqlDbType.VarChar).Value = Assembly.GetExecutingAssembly().GetName().Version.ToString();
                // @FactoryName value is not associated with an actual factory instance.  It's just a place holder for the management record.
                sqlCmd.Parameters.Add("@FactoryName", SqlDbType.VarChar).Value = "All Factories";
                ScanParms.ScanLogKey = (Int64)DataAccess.PostDataSqlCommand(sqlCmd, Config.SqlConnectionString, true);
            }
            catch (Exception ex)
            {
                string error = ex.ToString();
                ShowProgress(TaskName + " failed to create a scanlog entry into the management database.\r\n" + error);
                //Log Error to Event Log
                LogEvent(EventType.OnError.ToString()
                    , "CreateScanLog()"
                    , TaskName + " failed to create a scanlog entry into the management database."
                    , error);
            }
            finally
            {
                // Release the managed resource
                if (sqlCmd != null)
                {
                    sqlCmd.Dispose();
                }
            }
        }

        /// <summary>
        /// Updates the scan log.
        /// </summary>
        private int UpdateScanLog(string message, bool success, int recordFromId = -1, int recordToId = -1)
        {
            // Note: Not using a 'Using' statement with SqlCommand so we can process any exception caught at the DataLayer
            // The managed resource is disposed of in the finally block.
            // References: https://msdn.microsoft.com/en-us/library/aa355056%28v=vs.110%29.aspx
            // https://msdn.microsoft.com/en-us/library/yh598w02.aspx
            // https://msdn.microsoft.com/en-us/library/ms182334.aspx
            SqlCommand sqlCmd = new SqlCommand();
            int iAffected = 0;

            try
            {
                sqlCmd.CommandType = CommandType.StoredProcedure;
                if (Config.IsProduction)
                {
                    sqlCmd.CommandText = "[DataServicesManagement].[dbo].[ScanLogUpdate]";
                }
                else
                {
                    sqlCmd.CommandText = "[DataServicesManagementLab].[dbo].[ScanLogUpdate]";
                }

                sqlCmd.Parameters.Add("@ScanLogId", SqlDbType.BigInt).Value = ScanParms.ScanLogKey;
                sqlCmd.Parameters.Add("@ScanLogEndDate", SqlDbType.DateTime).Value = DateTime.UtcNow;
                sqlCmd.Parameters.Add("@ScanLogDescription", SqlDbType.VarChar).Value = message;

                if (success == true)
                {
                    sqlCmd.Parameters.Add("@SuccessFlag", SqlDbType.Bit).Value = 1;
                }
                else
                {
                    sqlCmd.Parameters.Add("@SuccessFlag", SqlDbType.Bit).Value = 0;
                }

                if (recordFromId == -1)
                {
                    sqlCmd.Parameters.Add("@FromRecordId", SqlDbType.Int).Value = DBNull.Value;
                }
                else
                {
                    sqlCmd.Parameters.Add("@FromRecordId", SqlDbType.Int).Value = recordFromId;
                }


                if (recordToId == -1)
                {
                    sqlCmd.Parameters.Add("@ToRecordId", SqlDbType.Int).Value = DBNull.Value;
                }
                else
                {
                    sqlCmd.Parameters.Add("@ToRecordId", SqlDbType.Int).Value = recordToId;
                }

                iAffected = (int)DataAccess.PostDataSqlCommand(sqlCmd, Config.SqlConnectionString, false);
            }
            catch (Exception ex)
            {
                string error = ex.ToString();
                //Log Error to Event Log
                LogEvent(EventType.OnError.ToString()
                    , "UpdateScanLog(string message, bool success, int recordFromId = -1, int recordToId = -1)"
                    , TaskName + " failed to update the scanlog."
                    , error);
            }
            finally
            {
                // Release the managed resource
                if (sqlCmd != null)
                {
                    sqlCmd.Dispose();
                }
            }

            return iAffected;
        }

        /// <summary>
        /// Tofs the log event.
        /// </summary>
        /// <param name="factory">The factory.</param>
        /// <param name="fileType">Type of the file.</param>
        /// <param name="file">The file.</param>
        /// <param name="serverPairKey">The server pair key.</param>
        /// <returns></returns>
        public Int64 TofLogEvent(string message, string factory, string fileType, string file, int serverPairKey = 0, long productInstanceKey = 0)
        {
            // Note: Not using a 'Using' statement with SqlCommand so we can process any exception caught at the DataLayer
            // The managed resource is disposed of in the finally block.
            // References: https://msdn.microsoft.com/en-us/library/aa355056%28v=vs.110%29.aspx
            // https://msdn.microsoft.com/en-us/library/yh598w02.aspx
            // https://msdn.microsoft.com/en-us/library/ms182334.aspx
            SqlCommand sqlCmd = new SqlCommand();
            Int64 id = 0;

            try
            {
                string taskName = Path.GetFileNameWithoutExtension(TaskName);
                if (taskName.Contains(".vshost"))
                {
                    taskName = taskName.Replace(".vshost", "");
                }
                sqlCmd.CommandType = CommandType.StoredProcedure;

                if (Config.IsProduction)
                {
                    sqlCmd.CommandText = "[DataServicesManagement].[dbo].[RemusTofEventLogCreate]";
                }
                else
                {
                    sqlCmd.CommandText = "[DataServicesManagementLab].[dbo].[RemusTofEventLogCreate]";
                }

                sqlCmd.Parameters.Add("@PackageName", SqlDbType.NVarChar).Value = taskName;
                sqlCmd.Parameters.Add("@FactoryName", SqlDbType.NVarChar).Value = factory;
                sqlCmd.Parameters.Add("@EventDescription", SqlDbType.NVarChar).Value = message;
                sqlCmd.Parameters.Add("@FileType", SqlDbType.NVarChar).Value = fileType;
                sqlCmd.Parameters.Add("@FileName", SqlDbType.NVarChar).Value = file;
                sqlCmd.Parameters.Add("@ScanLogKey", SqlDbType.BigInt).Value = ScanParms.ScanLogKey;
                if (productInstanceKey > 0)
                {
                    sqlCmd.Parameters.Add("@ProductInstanceKey", SqlDbType.BigInt).Value = productInstanceKey;
                }

                sqlCmd.Parameters.Add("@TransferServerPairKey", SqlDbType.Int).Value = serverPairKey;


                if (Config.SqlConnectionString == null) {
                    bool test = LoadTaskSettings();
                }

                id = (Int64)DataAccess.PostDataSqlCommand(sqlCmd, Config.SqlConnectionString, true);
            }
            catch (Exception ex)
            {
                string error = ex.ToString();
                // Log to NextGenTestServices 
                Logger.LogEvent(System.Diagnostics.EventLogEntryType.Error,
                    "Failed Method: TofLogEvent(), Error: " + error,
                    (int)ApplicationEventID.TOFTaskError,
                    (short)EventCategoryID.Tasks);
            }
            finally
            {
                // Release the managed resource
                if (sqlCmd != null)
                {
                    sqlCmd.Dispose();
                }
            }

            return id;
        }

        /// <summary>
        /// Creates an event log entry
        /// </summary>
        private Int64 LogEvent(string eventType, string sourceName, string eventMessage, string excpetionMessage)
        {
            // Note: Not using a 'Using' statement with SqlCommand so we can process any exception caught at the DataLayer
            // The managed resource is disposed of in the finally block.
            // References: https://msdn.microsoft.com/en-us/library/aa355056%28v=vs.110%29.aspx
            // https://msdn.microsoft.com/en-us/library/yh598w02.aspx
            // https://msdn.microsoft.com/en-us/library/ms182334.aspx
            SqlCommand sqlCmd = new SqlCommand();
            Int64 id = 0;

            try
            {
                //For Debugging, the TaskName will contain vshost.exe and will not be found. so we check for vshost, and rename.
                string taskName = Path.GetFileNameWithoutExtension(TaskName);
                if (taskName.Contains(".vshost"))
                {
                    taskName = taskName.Replace(".vshost", "");
                }
                sqlCmd.CommandType = CommandType.StoredProcedure;
                if (Config.IsProduction)
                {
                    sqlCmd.CommandText = "[DataServicesManagement].[dbo].[EventLogCreate]";
                }
                else
                {
                    sqlCmd.CommandText = "[DataServicesManagementLab].[dbo].[EventLogCreate]";
                }

                sqlCmd.Parameters.Add("@EventTypeName", SqlDbType.VarChar).Value = eventType;
                sqlCmd.Parameters.Add("@ScanLogId", SqlDbType.BigInt).Value = ScanParms.ScanLogKey;
                sqlCmd.Parameters.Add("@TransferServerPairId", SqlDbType.Int).Value = -1;
                sqlCmd.Parameters.Add("@PackageName", SqlDbType.VarChar).Value = taskName;
                sqlCmd.Parameters.Add("@ErrorId", SqlDbType.Int).Value = 1;
                sqlCmd.Parameters.Add("@ErrorDescription", SqlDbType.VarChar).Value = excpetionMessage;
                sqlCmd.Parameters.Add("@SourceName", SqlDbType.VarChar).Value = sourceName;
                sqlCmd.Parameters.Add("@SourceDescription", SqlDbType.VarChar).Value = DBNull.Value;
                sqlCmd.Parameters.Add("@PropagateFlag", SqlDbType.Bit).Value = 0;
                sqlCmd.Parameters.Add("@UserName", SqlDbType.VarChar).Value = "TaskScheduler";
                sqlCmd.Parameters.Add("@EventStartDate", SqlDbType.DateTime).Value = DateTime.UtcNow;
                sqlCmd.Parameters.Add("@EventLogDescription", SqlDbType.VarChar).Value = eventMessage;
                sqlCmd.Parameters.Add("@Serverid", SqlDbType.Int).Value = 6; //DataWarehouse Server Key

                id = (Int64)DataAccess.PostDataSqlCommand(sqlCmd, Config.SqlConnectionString, true);
            }
            catch (Exception ex)
            {
                string error = ex.ToString();
                // Log to NextGenTestServices 
                Logger.LogEvent(System.Diagnostics.EventLogEntryType.Error,
                    "Failed Method: LogEvent(string eventType, string sourceName, string eventMessage, string excpetionMessage)",
                    (int)ApplicationEventID.TOFTaskAction,
                    (short)EventCategoryID.Tasks);
            }
            finally
            {
                // Release the managed resource
                if (sqlCmd != null)
                {
                    sqlCmd.Dispose();
                }
            }

            return id;
        }

        /// <summary>
        /// Bulks the copy dynamic column mapping.
        /// </summary>
        /// <param name="dataTable">The data table.</param>
        /// <param name="destinationTable">The destination table.</param>
        /// <returns></returns>
        private bool BulkCopyDynamicColumnMapping(DataTable dataTable, string destinationTable)
        {
            bool result = false;

            try
            {
                // Perform a Bulk copy for gaining better performance
                // We explicitly specify the UseInternalTransaction option in the SqlBulkCopy class constructor to explicitly cause a bulk copy 
                // operation to execute in its own transaction, causing each batch of the bulk copy operation to execute within a separate transaction.
                // Different batches are executed in different transactions so if an error occurs during the bulk copy operation,
                // only the rows in the current batch will be rolled back. All other rows from previous batches will remain in the database.
                using (SqlBulkCopy bulkCopy = new SqlBulkCopy(Config.SqlConnectionString
                    , SqlBulkCopyOptions.UseInternalTransaction))
                {
                    // Dynamic Column Mapping
                    // Must ensure the Local DataTable has the same column names. 
                    // IMPORTANT:  Columns names are case sensitive.
                    foreach (DataColumn col in dataTable.Columns)
                    {
                        bulkCopy.ColumnMappings.Add(col.ColumnName, col.ColumnName);
                    }

                    bulkCopy.BulkCopyTimeout = 8000;
                    bulkCopy.BatchSize = 5000;
                    bulkCopy.DestinationTableName = destinationTable;

                    bulkCopy.WriteToServer(dataTable);
                    bulkCopy.Close();

                    //// Log to Management database Event Log
                    //LogEvent(EventType.OnInformation.ToString()
                    //    , Path.GetFileNameWithoutExtension(TaskName)
                    //    , "Bulk Insert for: " + destinationTable
                    //    , "");
                }
                result = true;
            }
            catch (Exception ex)
            {
                errorMessage = String.Empty;
                errorMessage = ex.ToString();

                ShowProgress("Error occurred during Bulk Insert: \r\n" + ex.ToString());
                LogEvent(EventType.OnError.ToString()
                    , Path.GetFileNameWithoutExtension(TaskName)
                    , "BulkCopyDynamicColumnMapping() for " + destinationTable
                    , ex.ToString());
            }
            return result;
        }

        #endregion Database Methods

        #region Dispose Methods

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Finalizes an instance of the <see cref="DSTaskTemplate"/> class.
        /// </summary>
        ~ProcessMemorySmartIMLTask()
        {
            // Finalizer calls Dispose(false)
            Dispose(false);
        }

        /// <summary>
        /// Releases unmanaged and - optionally - managed resources.
        /// </summary>
        /// <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
        protected virtual void Dispose(bool disposing)
        {
            if (disposing)
            {
                // free managed resources
                if (Logger != null)
                {
                    Logger.Dispose();
                    Logger = null;
                }
            }
        }

        #endregion Dispose Methods

        #endregion Design Pattern 

        #region Task Process Variables

        #region Database

        /// <summary>
        /// Gets the valid scan parameter.
        /// </summary>
        /// <returns></returns>
        private bool GetValidScanParameter()
        {
            bool result = false;
            string scanTo = String.Empty;

            if (Options.ManualDateRangeProcessing)
            {
                ScanParms.ScanFrom = Options.ManualFromDate;
                ScanParms.ScanTo = Options.ManualToDate;
                if (ScanParms.ScanFrom.Length > 0 && ScanParms.ScanTo.Length > 0)
                {
                    ShowProgress("Manual GetValidScanParameter Operation  was successful.", 1);
                    return true;
                }
     
            }


            string maximumTime = GetTofCreateTime();

            if (Config.TimeOffset != 0)
            {
                DateTime dt;
                if (ScanParms.ScanFrom.Length > 0)
                {
                    dt = Convert.ToDateTime(ScanParms.ScanFrom).AddHours(Config.TimeOffset);

                    if (Convert.ToDateTime(maximumTime) >= dt)
                    {
                        scanTo = dt.ToString(Iso8601DateFormatMap);
                    }
                }
                else
                {
                    if (Config.TimeOffset > 0)
                    {
                        Config.TimeOffset = Config.TimeOffset * -1;
                    }

                    ScanParms.ScanFrom = Convert.ToDateTime(maximumTime).AddHours(Config.TimeOffset).ToString(Iso8601DateFormatMap);
                }
            }

            if (scanTo.Length == 0)
            {
                scanTo = maximumTime;
            }

            ScanParms.ScanTo = scanTo;

            ShowProgress("Current Scan From Time: " + ScanParms.ScanFrom, 1);
            ShowProgress("Current Scan To Time: " + ScanParms.ScanTo, 1);

            if (ScanParms.ScanFrom.Length > 0 && ScanParms.ScanTo.Length > 0)
            {
                result = true;
            }

            return result;
        }

        /// <summary>
        /// Gets the tof create time.
        /// </summary>
        /// <returns></returns>
        private string GetTofCreateTime()
        {
            // Note: Not using a 'Using' statement with SqlCommand so we can process any exception caught at the DataLayer
            // The managed resource is disposed of in the finally block.
            // References: https://msdn.microsoft.com/en-us/library/aa355056%28v=vs.110%29.aspx
            // https://msdn.microsoft.com/en-us/library/yh598w02.aspx
            // https://msdn.microsoft.com/en-us/library/ms182334.aspx
            SqlCommand sqlCmd = new SqlCommand();
            string result = String.Empty;

            try
            {
                sqlCmd.CommandType = CommandType.StoredProcedure;

                if (Config.IsProduction)
                {
                    sqlCmd.CommandText = "[NextGenDW].[dbo].[tsk_RemusTofCreateTimeReadByName]";
                }
                else
                {
                    sqlCmd.CommandText = "[NextGenDWLab].[dbo].[tsk_RemusTofCreateTimeReadByName]";
                }

                sqlCmd.Parameters.Clear();
                sqlCmd.Parameters.Add("@TofName", SqlDbType.VarChar).Value = Config.TestOutputFileName;

                DataTable dt = (DataTable)DataAccess.GetDataSqlCommand(sqlCmd, false, Config.SqlConnectionString);

                if (dt.Rows.Count > 0)
                {
                    result = Convert.ToDateTime(dt.Rows[0]["Max_Create_dt"] + "").ToString(Iso8601DateFormatMap);
                }

            }
            catch (Exception ex)
            {
                errorMessage = String.Empty;
                errorMessage = ex.ToString();

                ShowProgress("Failed to read tof create time from database. \r\nError: " + ex.ToString());
                LogEvent(EventType.OnError.ToString()
                    , Path.GetFileNameWithoutExtension(TaskName)
                    , "GetTofCreateTime()"
                    , ex.ToString());
            }
            finally
            {
                if (sqlCmd != null)
                {
                    sqlCmd.Dispose();
                }
            }

            return result;
        }

        /// <summary>
        /// Gets the last successful process information.
        /// </summary>
        /// <returns></returns>
        private bool GetLastSuccessfulProcessInfo()
        {
            ShowProgress("Getting last successful data process information...", 1);

            // Note: Not using a 'Using' statement with SqlCommand so we can process any exception caught at the DataLayer
            // The managed resource is disposed of in the finally block.
            // References: https://msdn.microsoft.com/en-us/library/aa355056%28v=vs.110%29.aspx
            // https://msdn.microsoft.com/en-us/library/yh598w02.aspx
            // https://msdn.microsoft.com/en-us/library/ms182334.aspx

            if (Options.ManualDateRangeProcessing)
            {
                ScanParms.ScanFrom = Options.ManualFromDate;
                ScanParms.ScanTo = Options.ManualToDate;
                ShowProgress("Manual GetLastSuccessfulProcessInfo Operation  was successful.", 1);
                return   true;
            }


            SqlCommand sqlCmd = new SqlCommand();
            bool result = false;

            try
            {
                //For Debugging, the TaskName will contain vshost.exe and will not be found. so we check for vshost, and rename.
                string taskName = Path.GetFileNameWithoutExtension(TaskName);
                if (taskName.Contains(".vshost"))
                {
                    taskName = taskName.Replace(".vshost", "");
                }

                // Manual set date range for data processing
                if (Options.ManualDateRangeProcessing)
                {
                    ScanParms.ScanFrom = Options.ManualFromDate;
                    ScanParms.ScanTo = Options.ManualToDate;

                }
                else
                {
                    sqlCmd.CommandType = CommandType.StoredProcedure;

                    if (Config.IsProduction)
                    {
                        sqlCmd.CommandText = "[DataServicesManagement].[dbo].[tsk_GetLastSuccessfulTaskInfo]";
                    }
                    else
                    {
                        sqlCmd.CommandText = "[DataServicesManagementLab].[dbo].[tsk_GetLastSuccessfulTaskInfo]";
                    }

                    sqlCmd.Parameters.Clear();
                    sqlCmd.Parameters.Add("@PackageName", SqlDbType.NVarChar).Value = taskName;
                    sqlCmd.Parameters.Add("@Factory_nm", SqlDbType.NVarChar).Value = "All Factories";
                    //sqlCmd.Parameters.Add("@TransferServerPairKy", SqlDbType.Int).Value = 1;

                    //LogEvent(EventType.OnInformation.ToString()
                    //         , Path.GetFileNameWithoutExtension(taskName)
                    //         , "GetLastSuccessfulProcessInfo()"
                    //         , "");

                    // Log to NextGenTestServices 
                    Logger.LogEvent(System.Diagnostics.EventLogEntryType.Information,
                       TaskName + " task got the last success process information.",
                        (int)ApplicationEventID.TOFTaskAction,
                        (short)EventCategoryID.Tasks);

                    DataTable dt = (DataTable)DataAccess.GetDataSqlCommand(sqlCmd, false, Config.SqlConnectionString);

                    if (dt.Rows.Count > 0)
                    {
                        DataRow row = dt.Rows[0];

                        if ((row["ScanFrom"] + "").Length > 0)
                        {
                            ScanParms.ScanFrom = Convert.ToDateTime(row["ScanFrom"] + "").ToString(Iso8601DateFormatMap);
                        }
                        ShowProgress("Scan From Time: " + ScanParms.ScanFrom, 1);
                    }

                    //ShowProgress("Operation was successful.", 1);
                    //result = true;
                }
                ShowProgress("Operation was successful.", 1);
                result = true;
            }
            catch (Exception ex)
            {
                ShowProgress("Failed to read last successful process information. \r\nError: " + ex.ToString());
                // Log to NextGenTestServices 
                Logger.LogEvent(System.Diagnostics.EventLogEntryType.Error,
                   TaskName + " task failed to get the last success process information.",
                    (int)ApplicationEventID.TOFTaskAction,
                    (short)EventCategoryID.Tasks);
                //LogEvent(EventType.OnError.ToString()
                //    , Path.GetFileNameWithoutExtension(TaskName)
                //    , "GetLastSuccessfulProcessInfo()"
                //    , ex.ToString());
            }
            finally
            {
                if (sqlCmd != null)
                {
                    sqlCmd.Dispose();
                }
            }
            return result;
        }

        /// <summary>
        /// Gets the tof file data.
        /// </summary>
        /// <returns></returns>
        private bool GetTofFileData()
        {
            // Note: Not using a 'Using' statement with SqlCommand so we can process any exception caught at the DataLayer
            // The managed resource is disposed of in the finally block.
            // References: https://msdn.microsoft.com/en-us/library/aa355056%28v=vs.110%29.aspx
            // https://msdn.microsoft.com/en-us/library/yh598w02.aspx
            // https://msdn.microsoft.com/en-us/library/ms182334.aspx
            SqlCommand sqlCmd = new SqlCommand();
            bool result = false;

            try
            {
                TestOutputFiles.Clear();

                sqlCmd.CommandType = CommandType.StoredProcedure;
                //if (Config.IsProduction)
                //{
                    sqlCmd.CommandText = "[NextGenDW].[dbo].[tsk_RemusFactoryTofDataReadByFileName]";
                //}
                //else
                //{
                //    sqlCmd.CommandText = "[NextGenDWLab].[dbo].[tsk_RemusFactoryTofDataReadByFileName]";
                //}

                sqlCmd.Parameters.Clear();
                sqlCmd.Parameters.Add("@FromDate", SqlDbType.DateTime).Value = ScanParms.ScanFrom;
                sqlCmd.Parameters.Add("@ToDate", SqlDbType.DateTime).Value = ScanParms.ScanTo;
                sqlCmd.Parameters.Add("@TofName", SqlDbType.NVarChar).Value = Config.TestOutputFileName;

                TestOutputFiles = (DataTable)DataAccess.GetDataSqlCommand(sqlCmd, false, Config.SqlConnectionString);

                if (TestOutputFiles.Rows.Count > 0)
                {
                    result = true;
                }
            }
            catch (Exception ex)
            {
                ShowProgress("Failed to read ReMUS TOF file data. \r\nError: " + ex.ToString(), 1);
                LogEvent(EventType.OnError.ToString()
                    , Path.GetFileNameWithoutExtension(TaskName)
                    , "GetTofFileData()"
                    , ex.ToString());
            }
            finally
            {
                if (sqlCmd != null)
                {
                    sqlCmd.Dispose();
                }
            }
            return result;
        }

        #region Table

        private DataTable RequiredLocalTable = new DataTable();

        private void PrepLocalTable()
        {
            RequiredLocalTable.Columns.Clear();
            RequiredLocalTable.Columns.Add("Product_Instance_ky", typeof(Int64));
            RequiredLocalTable.Columns.Add("Geography_ky", typeof(int));
            RequiredLocalTable.Columns.Add("Device_Number_at", typeof(int));
            RequiredLocalTable.Columns.Add("Category_at", typeof(string));
            RequiredLocalTable.Columns.Add("Name_at", typeof(string));
            RequiredLocalTable.Columns.Add("Value_at", typeof(string));
            RequiredLocalTable.Columns.Add("Source_Create_dt", typeof(DateTime));
            RequiredLocalTable.Columns.Add("scan_log_ky", typeof(Int64));
        }

        #endregion Table

        private bool InsertFirmwareData(List<FirmwaredataObject> firmwares)
        {
            RequiredLocalTable.Clear();
            bool result = false;

            foreach (FirmwaredataObject fdo in firmwares)
            {
                DataRow row = RequiredLocalTable.NewRow();
                row["Product_Instance_ky"] = fdo.ProductInstanceKey;
                row["Geography_ky"] = fdo.GeographyKey;
                row["Device_Number_at"] = fdo.DeviceNumber;
                if (fdo.Category.Length > 0)
                {
                    row["Category_at"] = fdo.Category;
                }
                if (fdo.Name.Length > 0)
                {
                    row["Name_at"] = fdo.Name;
                }
                if (fdo.Data.Length > 0)
                {
                    row["Value_at"] = fdo.Data;
                }                
                row["Source_Create_dt"] = fdo.SouceCreateTime;
                row["scan_log_ky"] = ScanParms.ScanLogKey;

                RequiredLocalTable.Rows.Add(row);
            }

            if (RequiredLocalTable.Rows.Count > 0)
            {
                if (Config.IsProduction)
                {
                    result = BulkCopyDynamicColumnMapping(RequiredLocalTable, "[NextGenDW].[dbo].[Dim_Product_Firmware]");
                }
                else
                {
                    result = BulkCopyDynamicColumnMapping(RequiredLocalTable, "[NextGenDWLab].[dbo].[Dim_Product_Firmware]");
                }

            }
            return result;
        }

        #endregion Database

        #region File

        /// <summary>
        /// Processes the firmware file.
        /// </summary>
        /// <param name="data">The data.</param>
        /// <param name="productInstanceKey">The product instance key.</param>
        /// <param name="geographyKey">The geography key.</param>
        /// <param name="sourceCreateTime">The source create time.</param>
        /// <returns></returns>
        private bool ProcessFirmwareFile(string data, string productInstanceKey, string geographyKey, string sourceCreateTime)
        {
            bool result = false;

            try
            {
                XDocument xDoc = XDocument.Parse(data);

                var elements = xDoc.Descendants().Where(e => e.Name.LocalName.ToLowerInvariant() == "device");

                if (elements.Count() > 0)
                {
                    foreach (var el in elements)
                    {
                        string number = el.Attributes().Where(a => a.Name.LocalName.ToLowerInvariant() == "num").FirstOrDefault().Value;

                        if (el.Elements().Count() > 0)
                        {
                            foreach (var e in el.Elements())
                            {
                                string category = e.Name.LocalName;

                                string name = String.Empty;
                                if (e.Attributes().Count() > 0)
                                {
                                    name = e.Attributes().Where(a => a.Name.LocalName.ToLowerInvariant() == "name" ||
                                                                       a.Name.LocalName.ToLowerInvariant() == "property" ||
                                                                       a.Name.LocalName.ToLowerInvariant() == "type").FirstOrDefault().Value;
                                }

                                string value = e.Value;

                                FirmwaredataObject fdo = new FirmwaredataObject(productInstanceKey, geographyKey, number, category, name, value, sourceCreateTime);
                                firmwares.Add(fdo);
                            }
                        }
                    }

                    if (firmwares.Count > 0)
                    {
                        PrepLocalTable();

                        if (InsertFirmwareData(firmwares))
                        {
                            result = true;
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                errorMessage = String.Empty;
                errorMessage = ex.ToString();

                ShowProgress("Failed to process firmware data file. \r\nError: " + ex.ToString(), 1);
                LogEvent(EventType.OnError.ToString()
                    , Path.GetFileNameWithoutExtension(TaskName)
                    , "ProcessFirmwareFile()"
                    , ex.ToString());
            }
            return result;
        }

        /// <summary>
        /// Processes the test output file.
        /// </summary>
        /// <param name="row">The row.</param>
        /// <param name="client">The client.</param>
        /// <returns></returns>
        private bool ProcessTestOutputFile(DataRow row, LinuxSftpClient client)
        {
            bool result = false;

            try
            {
                string fileContent = String.Empty;
                long sourceFileSize = 0;
                string factoryName = (row["Factory_nm"] + "");
                string factoryAliasName = factoryName.Replace(" ", "-");
                string productID = row["ProductID_at"] + "";
                string serialNumber = row["Serial_Number_at"] + "";
                string workObject = row["Work_Object_at"] + "";
                string orderNumber = row["Order_Number_at"] + "";
                string memberID = row["Member_id"] + "";
                string factoryFileName = row["Factory_File_nm"] + "";
                string regionFileName = row["Region_File_nm"] + "";
                string productInstanceKey = row["Product_Instance_ky"] + "";
                string geographyKey = row["Geography_ky"] + "";
                string sourceCreateTime = Convert.ToDateTime(row["Source_Create_dt"]).ToString(Iso8601DateFormatMap);
                string path = GetAbsolutePath(Config.SourceWorkDirectory) + factoryAliasName +
                            @"/" + productID + @"/" + serialNumber + @"/" + regionFileName;
                //path = @"/sftp/guestuser/tofs/Foxconn-Juarez/864625-B21/2M291802PN/Foxconn Juarez_864625-B21_2M291802PN_18148_TOF_MemorySmartPPR.zip_2019-05-02T21-20-16.633Z_1078017.zippppp";


                ShowProgress("-- path Before: " + path, 1);

                path = @"/sftp/guestuser/tofs/Foxconn-Juarez/868703-B21/2M291802HJ/Foxconn Juarez_868703-B21_2M291802HJ_17849_TOF_MemorySmartPPR.zip_2019-05-02T10-14-27.350Z_1062098.zip";
                ShowProgress("-- path After: " + path, 1);

                ShowProgress("-- Current Region File Name: " + regionFileName, 1);

         

                using (MemoryStream outStream = new MemoryStream())
                {
                    client.DownloadFile(outStream, path);
                    sourceFileSize = client.GetFileSize(path);

                    long downloadSize = outStream.Length;

                    // Download successful
                    if (downloadSize == sourceFileSize)
                    {
                        using (var archive = new ZipArchive(outStream, ZipArchiveMode.Read))
                        {
                            foreach (var entry in archive.Entries)
                            {
                           
                                //if (entry.Name.ToLowerInvariant() == "memorysmartppr.zip")
                                if (entry.Name.ToLowerInvariant() == Config.TestOutputFileName.ToLower())
                                {
                         
                                    using (ZipArchive subArchive = new ZipArchive(entry.Open(), ZipArchiveMode.Read))
                                    {
                                        
                                        foreach (var e in subArchive.Entries)
                                        {
                                            //if (e.Name.ToLowerInvariant() == "iml_log.json")
                                            if (e.Name.ToLowerInvariant() == Config.FileType)
                                            {
                                                using (Stream content = e.Open())
                                                {
                                                    StreamReader sr = new StreamReader(content);
                                                    fileContent = sr.ReadToEnd();
                                                }

                                            }
                                        }
                                        //if (entry != null)
                                        //    entry = null;
                                    }

                                }
                                else
                                {
                                    using (Stream content = entry.Open())
                                    {
                                        StreamReader sr = new StreamReader(content);
                                        fileContent = sr.ReadToEnd();
                                    }
                                }

                                //if (entry != null)
                                //    entry = null;

                            }
                        
                        }
                    }
                }

                if (fileContent.Length > 0)
                {
                    //result = ProcessFirmwareFile(fileContent, productInstanceKey, geographyKey, sourceCreateTime);

                    bool InsertResult = false;
                    InsertResult = InertProductProduct(factoryName, productID, serialNumber, orderNumber, Convert.ToInt32(memberID), ScanParms.ScanLogKey, "ReMUS", 1); //IsFactoryAliasName = 1

                    if (InsertResult)
                    {
                        int Test_System_ky = 1; // "Remus"
                        int Product_ky = 0;
                        int Geography_ky = 0;



                        for (int x = 0; x < dtProKeyAndGeoKey.Rows.Count; x++)
                        {
                            Product_ky = Convert.ToInt32(dtProKeyAndGeoKey.Rows[x][0]);
                            Geography_ky = Convert.ToInt32(dtProKeyAndGeoKey.Rows[x][1]);

                        }
                        factoryFileName =
                                Geography_ky.ToString() + "_" +
                                memberID.ToString() + "_" +
                                productID.ToString() + "_" +
                                serialNumber.ToString() + "_" +
                                orderNumber.ToString() + "_" +
                                Guid.NewGuid().ToString() + "_" +
                                factoryFileName.ToString();

                        IMLParse IML = new IMLParse(fileContent, Product_ky, Geography_ky, Test_System_ky, Convert.ToInt32(memberID), factoryFileName, regionFileName, ScanParms.ScanLogKey, Config.SqlConnectionString, factoryName, Path.GetFileNameWithoutExtension(TaskName), Convert.ToInt64(productInstanceKey), Config.FileType, Config.TestOutputFileName, serialNumber, sourceCreateTime);
                        IML.Run();
                        dtProKeyAndGeoKey.Clear();
                        return true;
                    }
                }
            }
            catch (Exception ex)
            {
                errorMessage = String.Empty;
                errorMessage = ex.ToString();

                ShowProgress("Failed to process ReMUS test output file. \r\nError: " + ex.ToString(), 1);
                LogEvent(EventType.OnError.ToString()
                    , Path.GetFileNameWithoutExtension(TaskName)
                    , "ProcessTestOutputFile()"
                    , ex.ToString());
            }
            finally
            {
                

            }
            return result;
        }


        private bool InertProductProduct(string factoryName, string productID, string serialNumber,
                string orderNumber, int memberID, long scanLogKey, string TestSystem, int IsFactoryAliasName)
        {
            //factoryName,productID,serialNumber,orderNumber,memberID,ScanParms.ScanLogKey,1,0
            try
            {
                using (SqlConnection oConn = new SqlConnection(Config.SqlConnectionString))
                {
                    //DataTable dt = new DataTable();
                    SqlDataAdapter oAdapt = new SqlDataAdapter();
                    SqlCommand oCmd = new SqlCommand();

                    oConn.Open();
          
                    oCmd.CommandType = CommandType.StoredProcedure;
                    oCmd.CommandText = "[NextGenTOF].[TOF].[ProcessTOFProduct]";
                    oCmd.Connection = oConn;
                    oCmd.Parameters.AddWithValue("@FactoryName", factoryName);
                    oCmd.Parameters.AddWithValue("@ProductID", productID);
                    oCmd.Parameters.AddWithValue("@SerialNumber", serialNumber);
                    oCmd.Parameters.AddWithValue("@OrderNumber", orderNumber);
                    oCmd.Parameters.AddWithValue("@MemberID", memberID);
                    oCmd.Parameters.AddWithValue("@ScanLogKey", scanLogKey);
                    oCmd.Parameters.AddWithValue("@TestSystem", TestSystem); // Hard Coded to 1
                    oCmd.Parameters.AddWithValue("@IsFactoryAliasName", IsFactoryAliasName); // Hard coded to 0

                    oAdapt.SelectCommand = oCmd;
                    oAdapt.Fill(dtProKeyAndGeoKey);
                    oAdapt.Dispose();

                }
            }
            catch (SqlException ex)
            {
                 //Need to Inter Record int the REMUS EVENT LOG table
                string error = ex.ToString();
                // Log to NextGenTestServices 
                Logger.LogEvent(System.Diagnostics.EventLogEntryType.Error,
                    " Line: 1306, Failed Method: InertProductProduct(factoryName,  productID,  serialNumber, orderNumber,  memberID,  scanLogKey,  TestSystem,  IsFactoryAliasName)",
                    (int)ApplicationEventID.TOFTaskAction,
                    (short)EventCategoryID.Tasks);
                return false;
             }

            return true;
        }

        string errorMessage = String.Empty;

        /// <summary>
        /// Processes the tof reference data.
        /// </summary>
        private void ProcessTofReferenceData()
        {
            bool isProcessSuccessful = false;

            try
            {
                if (GetLastSuccessfulProcessInfo())
                {
                    if (GetValidScanParameter())
                    {
                        
                        CreateScanLog();
                        ShowProgress("Current ScanLogKey: " + ScanParms.ScanLogKey, 1);

                        if (ScanParms.ScanLogKey > 0)
                        {
                            string errorLogName = GetWindowsAbsolutePath(Config.EventLogPath) + Path.GetFileNameWithoutExtension(TaskName) + "-PROCESS-FAILED-" + ScanParms.ScanLogKey + ".log";
                            ShowProgress("Event Log File Name: " + errorLogName, 1);

                            // If Scan from time equals the latest record create time in [Dim_Test_Output_File] table
                            if (IsStartProcess())
                            {
                                bool isSuccessful = GetTofFileData();

                                int fileFoundCount = 0;
                                int fileUpdateCount = 0;

                                if (isSuccessful)
                                {
                                    LinuxSftpClient client = new LinuxSftpClient(Config.SourceHost, Config.SourcePort, Config.SourceUserName, Config.SourcePassword);
                                    client.Open();

                                    if (client.IsConnected)
                                    {
                                        fileFoundCount = TestOutputFiles.Rows.Count;
                                        ShowProgress("Found " + Config.TestOutputFileName + ", file count: " + fileFoundCount, 1);

                                        foreach (DataRow row in TestOutputFiles.Rows)
                                        {
                                            string regionFileName = row["Region_File_nm"] + "";

                                            if (!ProcessTestOutputFile(row, client))
                                            {
                                                ShowProgress("--Failed Process File: " + regionFileName, 1);

                                                if (errorMessage.Trim().Length == 0)
                                                    errorMessage = "Iml_log.json file not found in MemorySmartPpr.zip ";

                                                TofLogEvent(errorMessage, row["Factory_nm"] + "", Config.TestOutputFileName, regionFileName, 1, Convert.ToInt64(row["Product_Instance_ky"] + ""));
                                                errorMessage = "";
                                                //EventLogger nLogger = new EventLogger(errorLogName, true);
                                                //nLogger.Open();
                                                //nLogger.Write(regionFileName);
                                                //nLogger.Close();

                                                //// Event Log Failed
                                                //if (!nLogger.IsLogged)
                                                //{
                                                //    LogEvent(EventType.OnError.ToString()
                                                //        , Path.GetFileNameWithoutExtension(TaskName)
                                                //        , "ProcessTofReferenceData()"
                                                //        , regionFileName);
                                                //}
                                            }
                                            else
                                            {
                                                fileUpdateCount = fileUpdateCount + 1;
                                            }
                                        }
                                    }
                                    client.Close();

                                    if (!isProcessSuccessful)
                                    {
                                        if (fileUpdateCount > 0)
                                        {
                                            UpdateScanLog(TaskName + " task has completed. File found: " + fileFoundCount + ", File processed: " + fileUpdateCount, true);
                                        }
                                        else
                                        {
                                            UpdateScanLog("No data processed.", true);
                                        }
                                    }
                                    else
                                    {
                                        UpdateScanLog("Failed to process Remus commodity file.", false);
                                    }
                                }
                                else
                                {
                                    // No new data record be found
                                    UpdateScanLog("No data processed.", true);
                                }
                            }
                            else
                            {
                                // No new data record be found
                                UpdateScanLog("No data processed.", true);
                            }
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                ShowProgress("Failed to process ReMUS BOM file data. \r\nError: " + ex.ToString(), 1);
                LogEvent(EventType.OnError.ToString()
                    , Path.GetFileNameWithoutExtension(TaskName)
                    , "ProcessTofReferenceData()"
                    , ex.ToString());
            }
        }

        #endregion File

        #region Methods

        /// <summary>
        /// Determines whether [is start process].
        /// </summary>
        /// <returns>
        ///   <c>true</c> if [is start process]; otherwise, <c>false</c>.
        /// </returns>
        private bool IsStartProcess()
        {
            bool result = false;

            if (ScanParms.ScanFrom.Length > 0 && ScanParms.ScanTo.Length > 0)
            {
                if (Convert.ToDateTime(ScanParms.ScanFrom) < Convert.ToDateTime(ScanParms.ScanTo))
                {
                    result = true;
                }
            }
            return result;
        }

        /// <summary>
        /// Gets the regex result.
        /// </summary>
        /// <param name="input">The input.</param>
        /// <param name="pattern">The pattern.</param>
        /// <returns></returns>
        private string GetRegexResult(string input, string pattern)
        {
            string result = String.Empty;

            return Regex.IsMatch(input, pattern) ? Regex.Match(input, pattern).Value : result;
        }

        /// <summary>
        /// Gets the absolute path.
        /// </summary>
        /// <param name="path">The path.</param>
        /// <returns></returns>
        private string GetAbsolutePath(string path)
        {
            string result = String.Empty;

            if (!path.EndsWith("/"))
            {
                result = path + "/";
            }
            else
            {
                result = path;
            }

            return result;
        }

        /// <summary>
        /// Gets the windows absolute path.
        /// </summary>
        /// <param name="path">The path.</param>
        /// <returns></returns>
        private string GetWindowsAbsolutePath(string path)
        {
            string result = String.Empty;
            if (!path.EndsWith("\\"))
            {
                result = path + "\\";
            }
            else
            {
                result = path;
            }
            return result;
        }

        #endregion Methods

        #endregion Task Process Variables

    }
}