using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Xml;
using System.Xml.Linq;
using System.Data;
using System.Data.SqlClient;
using System.ComponentModel;
using System.Reflection;
using System.IO.Compression;
using System.Net.Mail;
using System.Text.RegularExpressions;
using DataServicesGlobalReportingDataAccess.DataLayer;
using DataServicesGlobalReportingDataLogger;
using ConsoleSpinner;


namespace RemusProcessMemorySmatXMLTask
{
    /// <summary>
    /// This class is the <see cref="ProcessMemorySmatXMLTask" />, <see cref="ProcessMemorySmatXMLTask" /> which contains the methods to process ReMUS xxxxxx Test Output Files.
    /// </summary>
    /// <remarks>
    /// Author: Simonely Hidalgo
    /// <para/>Created:  5/10/2019
    /// <para/>Modified By: 
    /// <para/>Date: 
    /// </remarks> 
    /// <seealso cref="System.IDisposable" />
    public class ProcessMemorySmatXMLTask : IDisposable
    {
        #region Design Pattern Constants

        /// <summary>
        /// The ISO 8601 date format map
        /// </summary>
        const string Iso8601DateFormatMap = "yyyy-MM-ddTHH:mm:ss.fffffff";

        #endregion Design Pattern Constants

        #region Design Patttern Variables

        /// <summary>
        /// The tof
        /// </summary>
        //TOFProcessing TOF = new TOFProcessing();

        /// <summary>
        /// The logger
        /// </summary>
        DataLogger Logger = new DataLogger();

        /// <summary>
        /// The configuration
        /// </summary>
        TaskConfig Config = new TaskConfig();

        /// <summary>
        /// The console spiner
        /// </summary>
        Spinner ConsoleSpiner = new Spinner();

        /// <summary>
        /// The Command Line Options
        /// </summary>
        CommandLineOptions Options = new CommandLineOptions();

        /// <summary>
        /// The deployment settingson
        /// </summary>
        /// <summary>
        /// The data access layer
        /// </summary>
        DataAccessFacade DataAccess = new DataAccessFacade();
 
        /// <summary>
        /// The task name
        /// </summary>
        String TaskName = Path.GetFileName(Environment.GetCommandLineArgs()[0]);

        /// <summary>
        /// The location the task is executing from
        /// </summary>
        String TaskLocation = System.IO.Path.GetDirectoryName(System.Reflection.Assembly.GetEntryAssembly().Location);
        enum EventType {
            OnError,
            OnTaskFailed,
            CustomInformation,
            OnPostExecute,
            OnPreExecute,
            OnInformation,
            OnProgress,
            OnWarning,
                        }

        #endregion Design Patttern Variables

        #region Task Process Variables

        string TaskPurpose = "This is a Data Services ReMUS Task for processing MemorySmartPpr.xml file generated by the ReMUS Test Executive and founded into MemorySmartPpr.zip .\r\n" +
                             "The associated JSON file is the configuration file for automated processing of these TOFs.\r\n\r\n";

        DataTable TestOutputFiles = new DataTable();

        ScanParameter ScanParms = new ScanParameter();

        List<TOFdataObject> xmlDataList = new List<TOFdataObject>();


        #endregion Task Process Variables

        #region Design Pattern 

        #region Main Startup Methods

        /// <summary>
        /// Runs the specified arguments.
        /// </summary>
        /// <param name="args">The arguments.</param>
        public void Run(string[] args)
        {
            //Enable log writing for alla events. Tese values will set when the confirutation file loads. 
            // Set Loging
            Logger.LogErrors = true;
            Logger.LogFailureAudits = true;
            Logger.LogInformation = true;
            Logger.LogSuccessAudits = true;
            Logger.LogWarnings = true;

            if (ProcessArguments(args))
            {
                ShowProgress(TaskName + " task has started...");

                // Log to NextGenTestServices 
                Logger.LogEvent(System.Diagnostics.EventLogEntryType.Information,
                   TaskName + " task has started.",
                    (int)ApplicationEventID.TOFTaskStart,
                    (short)EventCategoryID.Tasks);


                if (LoadTaskSettings())
                {
                    Spinner.Start();

                    StartProcess();

                    Spinner.Stop();
                }

                ShowProgress(TaskName + " task has finished.");

                // Log to NextGenTestServices 
                Logger.LogEvent(System.Diagnostics.EventLogEntryType.Information,
                    TaskName + " task has finished.",
                    (int)ApplicationEventID.TOFTaskComplete,
                    (short)EventCategoryID.Tasks);

            }
        }

        /// <summary>
        /// Processes the arguments.
        /// </summary>
        /// <param name="args">The arguments.</param>
        private bool ProcessArguments(string[] args)
        {
            bool result = true;
            var options = String.Empty;
            var version = System.Reflection.Assembly.GetExecutingAssembly().GetName().Version;

            for (int i = 0; i < args.Length; i++)
            {
                if (args[i].ToLower() == "-d")
                {
                    Options.ShowDetail = true;
                    options = options + args[i] + " ";
                }
                if (args[i].ToLower() == "-i")
                {
                    Options.Interactive = true;
                    options = options + args[i] + " ";
                }
                if (args[i].ToLower() == "-h")
                {
                    ShowHelp(args);
                    return false;
                }
                if (args[i].ToLower().Contains("-from="))
                {
                    string[] s = args[i].Split('=');
                    Options.ManualFromDate = s[1];
                    //Need to add the double quote around the DateTime value to match the commad line input
                    string value = args[i].Insert(5, "\"");
                    options = options + value.Insert(value.Length, "\"") + " ";
                }
                if (args[i].ToLower().Contains("-to="))
                {
                    string[] s = args[i].Split('=');
                    Options.ManualToDate = s[1];
                    //Need to add the double quote around the DateTime value to match the commad line input
                    string value = args[i].Insert(3, "\"");
                    options = options + value.Insert(value.Length, "\"") + " ";
                }
                if (args[i].ToLower() == "-m")
                {
                    Options.ManualDateRangeProcessing = true;
                    options = options + args[i] + " ";
                }
            }

            Console.WriteLine("Starting {0} \r\n\tOptions {1} \r\n\tVersion {2} \r\n", TaskName, options, version.ToString());
            //Evaluate Options
            if (Options.ManualDateRangeProcessing)
            {
                // Check for From and To
                if (Options.ManualFromDate != null)
                {
                    if (Options.ManualFromDate.Trim().Length == 0)
                    {
                        ShowProgress(@"-m Option requires a valid From Date value. See help for more information.", 1);
                        Options.ManualDateRangeProcessing = false;
                    }
                }
                else
                {
                    ShowProgress(@"-m Option requires a valid From Date value. See help for more information.", 1);
                    Options.ManualDateRangeProcessing = false;
                }

                if (Options.ManualToDate != null)
                {
                    if (Options.ManualToDate.Trim().Length == 0)
                    {
                        ShowProgress(@"-m Option requires a valid To Date value. See help for more information.", 1);
                        Options.ManualDateRangeProcessing = false;
                    }
                }
                else
                {
                    ShowProgress(@"-m Option requires a valid To Date value. See help for more information.", 1);
                    Options.ManualDateRangeProcessing = false;
                }

                // Validate From and To
                if (!IsValidDate(Options.ManualFromDate))
                {
                    ShowProgress("From Date is not a valid DateTime value.", 1);
                    Options.ManualDateRangeProcessing = false;
                }

                if (!IsValidDate(Options.ManualFromDate))
                {
                    ShowProgress("From Date is not a valid DateTime value.", 1);
                    Options.ManualDateRangeProcessing = false;
                }
                result = Options.ManualDateRangeProcessing;
            }
            else
            {
                result = true;
            }
            return result;
        }

        /// <summary>
        /// Shows the help.
        /// </summary>
        /// <param name="args">The arguments.</param>
        private void ShowHelp(string[] args)
        {
            Console.WriteLine("{1} running from {0}.", TaskLocation,
                TaskName);
            Console.WriteLine("");
            Console.Write(TaskPurpose);
            Console.WriteLine("Command Line Options:\r\n");
            Console.WriteLine("-h : Displays this help information.\r\n");
            Console.WriteLine("-d : Show details during processing.  This option will pause the task at the end so is should not be set as a default option in production.\r\n");
            Console.WriteLine("-i : Show details during process as well requireing user input to proceed to the next step. This option should not be set as a default option in production.\r\n");
            Console.WriteLine("-f : This option requires a path to a list of files for processing.  ex. -f|c:\temp\filelist.txt \r\n.This option will override automated processing to allow processing of a specific set of files and is not limited to the configuration property 'MaxFilesToProcess'.\r\n");
            Console.WriteLine("press any key to exit...");
            Console.ReadKey();
        }

        /// <summary>
        /// Starts the process.
        /// </summary>
        private void StartProcess()
        {
            ProcessTofReferenceData();
        }

        #endregion Main Startup Methods

        #region Helper Methods

        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        ///   <c>true</c> if [is valid date] [the specified value]; otherwise, <c>false</c>.
        /// </returns>
        private bool IsValidDate(string value)
        {
            DateTime dateValue;

            if (DateTime.TryParse(value, out dateValue))
                return true;
            else
                return false;
        }

        /// <summary>
        /// Shows the progress.
        /// </summary>
        /// <param name="waitForKeyPress">if set to <c>true</c> [wait for key press].</param>
        /// <param name="output">The output.</param>
        private void ShowProgress(string output, int indentLevel = 0)
        {
            string indent = "";
            for (int idx = 0; idx < indentLevel; idx++)
            {
                indent = indent + "\t";
            }

            if (Options.Interactive || Options.ShowDetail)
            {
                if (Options.Interactive)
                {
                    Console.WriteLine(indent + output + "\r\nPress Any Key to continue...\r\n");
                    Console.ReadKey();
                }
                else
                {
                    Console.WriteLine(indent + output + "\r\n");
                }
            }
        }

        /// <summary>
        /// Loads the service settings.
        /// To update the service settings you use a windows application for managing Data Services NextGen Services that was installed wtih this service.
        /// </summary>
        private bool LoadTaskSettings()
        {
            // Note: Not using a 'Using' statement with the stream reader  so we can process any exception caught
            // The managed resource is disposed of in the finally block.
            // References: https://msdn.microsoft.com/en-us/library/aa355056%28v=vs.110%29.aspx
            // https://msdn.microsoft.com/en-us/library/yh598w02.aspx
            // https://msdn.microsoft.com/en-us/library/ms182334.aspx

            StreamReader file = null;
            bool result = false;

            try
            {
                ShowProgress("Loading configuration file: " + TaskLocation + "\\" + Path.GetFileNameWithoutExtension(TaskName) + ".json");
                // Load the seettings
                file = File.OpenText(TaskLocation + "\\" + Path.GetFileNameWithoutExtension(TaskName) + ".json");

                Console.WriteLine("Loading setting from JSON config file: {0}", TaskLocation + @"\" + Path.GetFileNameWithoutExtension(TaskName) + ".json");

                JsonSerializer serializer = new JsonSerializer();
                Config = (TaskConfig)serializer.Deserialize(file, typeof(TaskConfig));

                // Set Loging based on config file
                Logger.LogErrors = Config.LogErrors;
                Logger.LogFailureAudits = Config.LogFailureAudits;
                Logger.LogInformation = Config.LogInformation; ;
                Logger.LogSuccessAudits = Config.LogSuccessAudits;
                Logger.LogWarnings = Config.LogWarnings;

                result = true;
            }
            catch (Exception ex)
            {
                ShowProgress(TaskName + " could not start due to an error accessing the json configuration file: " + TaskLocation + "\\" + Path.GetFileNameWithoutExtension(TaskName) + ".json");
                // Log to NextGenTestServices 
                Logger.LogEvent(System.Diagnostics.EventLogEntryType.Error,
                     TaskName + " could not start due to an error accessing the json configuration file: " + TaskLocation + @"\" + Path.GetFileNameWithoutExtension(TaskName) + ".json" + "\r\n" + ex.ToString(),
                   (int)ApplicationEventID.TOFTaskError,  //NOTE YOU NEED TO ADD ADDITIONAL EVENTS TO THE DATA LOGGER CLASS
                   (short)EventCategoryID.Tasks);

                // Log to Management database Event Log
                LogEvent(EventType.OnError.ToString()
                    , "LoadTaskSettings()"
                    , TaskName + " could not start due to an error accessing the json configuration file: " + TaskLocation + @"\" + Path.GetFileNameWithoutExtension(TaskName) + ".json"
                    , ex.ToString());
            }
            finally
            {
                if (file != null)
                {
                    file.Dispose();
                }
            }

            return result;
        }

        #endregion Helper Methods

        #region Database Methods

        /// <summary>
        /// Creates the scan log.
        /// </summary>
        private void CreateScanLog()
        {
            // Note: Not using a 'Using' statement with SqlCommand so we can process any exception caught at the DataLayer
            // The managed resource is disposed of in the finally block.
            // References: https://msdn.microsoft.com/en-us/library/aa355056%28v=vs.110%29.aspx
            // https://msdn.microsoft.com/en-us/library/yh598w02.aspx
            // https://msdn.microsoft.com/en-us/library/ms182334.aspx
            SqlCommand sqlCmd = new SqlCommand();

            try
            {
                //For Debugging, the TaskName will contain vshost.exe and will not be found. so we check for vshost, and rename.
                string taskName = Path.GetFileNameWithoutExtension(TaskName);
                if (taskName.Contains(".vshost"))
                {
                    taskName = taskName.Replace(".vshost", "");
                }
                sqlCmd.CommandType = CommandType.StoredProcedure;
                if (Config.IsProduction)
                {
                    sqlCmd.CommandText = "[DataServicesManagement].[dbo].[ScanLogCreate]";
                }
                else
                {
                    sqlCmd.CommandText = "[DataServicesManagementLab].[dbo].[ScanLogCreate]";
                }

                sqlCmd.Parameters.Add("@PackageName", SqlDbType.VarChar).Value = taskName;
                sqlCmd.Parameters.Add("@ScanLogStartDate", SqlDbType.DateTime).Value = DateTime.UtcNow;
                sqlCmd.Parameters.Add("@ScanLogEndDate", SqlDbType.DateTime).Value = DBNull.Value;
                sqlCmd.Parameters.Add("@ScanLogFromDate", SqlDbType.DateTime).Value = ScanParms.ScanFrom;
                sqlCmd.Parameters.Add("@ScanLogToDate", SqlDbType.DateTime).Value = ScanParms.ScanTo;
                sqlCmd.Parameters.Add("@ScanLogDescription", SqlDbType.VarChar).Value = TaskName + " starting...";
                sqlCmd.Parameters.Add("@SuccessFlag", SqlDbType.Bit).Value = 0;
                sqlCmd.Parameters.Add("@FromRecordId", SqlDbType.Int).Value = DBNull.Value;
                sqlCmd.Parameters.Add("@ToRecordId", SqlDbType.Int).Value = DBNull.Value;
                sqlCmd.Parameters.Add("@PackageVersion", SqlDbType.VarChar).Value = Assembly.GetExecutingAssembly().GetName().Version.ToString();
                // @FactoryName value is not associated with an actual factory instance.  It's just a place holder for the management record.
                sqlCmd.Parameters.Add("@FactoryName", SqlDbType.VarChar).Value = "All Factories";
                ScanParms.ScanLogKey = (Int64)DataAccess.PostDataSqlCommand(sqlCmd, Config.SqlConnectionString, true);
            }
            catch (Exception ex)
            {
                string error = ex.ToString();
                ShowProgress(TaskName + " failed to create a scanlog entry into the management database.\r\n" + error);
                //Log Error to Event Log
                LogEvent(EventType.OnError.ToString()
                    , "CreateScanLog()"
                    , TaskName + " failed to create a scanlog entry into the management database."
                    , error);
            }
            finally
            {
                // Release the managed resource
                if (sqlCmd != null)
                {
                    sqlCmd.Dispose();
                }
            }
        }

        /// <summary>
        /// Updates the scan log.
        /// </summary>
        private int UpdateScanLog(string message, bool success, int recordFromId = -1, int recordToId = -1)
        {
            // Note: Not using a 'Using' statement with SqlCommand so we can process any exception caught at the DataLayer
            // The managed resource is disposed of in the finally block.
            // References: https://msdn.microsoft.com/en-us/library/aa355056%28v=vs.110%29.aspx
            // https://msdn.microsoft.com/en-us/library/yh598w02.aspx
            // https://msdn.microsoft.com/en-us/library/ms182334.aspx
            SqlCommand sqlCmd = new SqlCommand();
            int iAffected = 0;

            try
            {
                sqlCmd.CommandType = CommandType.StoredProcedure;
                if (Config.IsProduction)
                {
                    sqlCmd.CommandText = "[DataServicesManagement].[dbo].[ScanLogUpdate]";
                }
                else
                {
                    sqlCmd.CommandText = "[DataServicesManagementLab].[dbo].[ScanLogUpdate]";
                }

                sqlCmd.Parameters.Add("@ScanLogId", SqlDbType.BigInt).Value = ScanParms.ScanLogKey;
                sqlCmd.Parameters.Add("@ScanLogEndDate", SqlDbType.DateTime).Value = DateTime.UtcNow;
                sqlCmd.Parameters.Add("@ScanLogDescription", SqlDbType.VarChar).Value = message;

                if (success == true)
                {
                    sqlCmd.Parameters.Add("@SuccessFlag", SqlDbType.Bit).Value = 1;
                }
                else
                {
                    sqlCmd.Parameters.Add("@SuccessFlag", SqlDbType.Bit).Value = 0;
                }

                if (recordFromId == -1)
                {
                    sqlCmd.Parameters.Add("@FromRecordId", SqlDbType.Int).Value = DBNull.Value;
                }
                else
                {
                    sqlCmd.Parameters.Add("@FromRecordId", SqlDbType.Int).Value = recordFromId;
                }


                if (recordToId == -1)
                {
                    sqlCmd.Parameters.Add("@ToRecordId", SqlDbType.Int).Value = DBNull.Value;
                }
                else
                {
                    sqlCmd.Parameters.Add("@ToRecordId", SqlDbType.Int).Value = recordToId;
                }

                iAffected = (int)DataAccess.PostDataSqlCommand(sqlCmd, Config.SqlConnectionString, false);
            }
            catch (Exception ex)
            {
                string error = ex.ToString();
                //Log Error to Event Log
                LogEvent(EventType.OnError.ToString()
                    , "UpdateScanLog(string message, bool success, int recordFromId = -1, int recordToId = -1)"
                    , TaskName + " failed to update the scanlog."
                    , error);
            }
            finally
            {
                // Release the managed resource
                if (sqlCmd != null)
                {
                    sqlCmd.Dispose();
                }
            }

            return iAffected;
        }

        /// <summary>
        /// Tofs the log event.
        /// </summary>
        /// <param name="factory">The factory.</param>
        /// <param name="fileType">Type of the file.</param>
        /// <param name="file">The file.</param>
        /// <param name="serverPairKey">The server pair key.</param>
        /// <returns></returns>
        private Int64 TofLogEvent(string message, string factory, string fileType, string file, int serverPairKey = 0, long productInstanceKey = 0)
        {
            // Note: Not using a 'Using' statement with SqlCommand so we can process any exception caught at the DataLayer
            // The managed resource is disposed of in the finally block.
            // References: https://msdn.microsoft.com/en-us/library/aa355056%28v=vs.110%29.aspx
            // https://msdn.microsoft.com/en-us/library/yh598w02.aspx
            // https://msdn.microsoft.com/en-us/library/ms182334.aspx
            SqlCommand sqlCmd = new SqlCommand();
            Int64 id = 0;

            try
            {
                string taskName = Path.GetFileNameWithoutExtension(TaskName);
                if (taskName.Contains(".vshost"))
                {
                    taskName = taskName.Replace(".vshost", "");
                }
                sqlCmd.CommandType = CommandType.StoredProcedure;

                if (Config.IsProduction)
                {
                    sqlCmd.CommandText = "[DataServicesManagement].[dbo].[RemusTofEventLogCreate]";
                }
                else
                {
                    sqlCmd.CommandText = "[DataServicesManagementLab].[dbo].[RemusTofEventLogCreate]";
                }

                sqlCmd.Parameters.Add("@PackageName", SqlDbType.NVarChar).Value = taskName;
                sqlCmd.Parameters.Add("@FactoryName", SqlDbType.NVarChar).Value = factory;
                sqlCmd.Parameters.Add("@EventDescription", SqlDbType.NVarChar).Value = message;
                sqlCmd.Parameters.Add("@FileType", SqlDbType.NVarChar).Value = fileType;
                sqlCmd.Parameters.Add("@FileName", SqlDbType.NVarChar).Value = file;
                sqlCmd.Parameters.Add("@ScanLogKey", SqlDbType.BigInt).Value = ScanParms.ScanLogKey;
                if (productInstanceKey > 0)
                {
                    sqlCmd.Parameters.Add("@ProductInstanceKey", SqlDbType.BigInt).Value = productInstanceKey;
                }

                sqlCmd.Parameters.Add("@TransferServerPairKey", SqlDbType.Int).Value = serverPairKey;

                id = (Int64)DataAccess.PostDataSqlCommand(sqlCmd, Config.SqlConnectionString, true);
            }
            catch (Exception ex)
            {
                string error = ex.ToString();
                // Log to NextGenTestServices 
                Logger.LogEvent(System.Diagnostics.EventLogEntryType.Error,
                    "Failed Method: TofLogEvent(), Error: " + error,
                    (int)ApplicationEventID.TOFTaskError,
                    (short)EventCategoryID.Tasks);
            }
            finally
            {
                // Release the managed resource
                if (sqlCmd != null)
                {
                    sqlCmd.Dispose();
                }
            }

            return id;
        }

        /// <summary>
        /// Creates an event log entry
        /// </summary>
        private Int64 LogEvent(string eventType, string sourceName, string eventMessage, string excpetionMessage)
        {
            // Note: Not using a 'Using' statement with SqlCommand so we can process any exception caught at the DataLayer
            // The managed resource is disposed of in the finally block.
            // References: https://msdn.microsoft.com/en-us/library/aa355056%28v=vs.110%29.aspx
            // https://msdn.microsoft.com/en-us/library/yh598w02.aspx
            // https://msdn.microsoft.com/en-us/library/ms182334.aspx
            SqlCommand sqlCmd = new SqlCommand();
            Int64 id = 0;

            try
            {
                //For Debugging, the TaskName will contain vshost.exe and will not be found. so we check for vshost, and rename.
                string taskName = Path.GetFileNameWithoutExtension(TaskName);
                if (taskName.Contains(".vshost"))
                {
                    taskName = taskName.Replace(".vshost", "");
                }
                sqlCmd.CommandType = CommandType.StoredProcedure;
                if (Config.IsProduction)
                {
                    sqlCmd.CommandText = "[DataServicesManagement].[dbo].[EventLogCreate]";
                }
                else
                {
                    sqlCmd.CommandText = "[DataServicesManagementLab].[dbo].[EventLogCreate]";
                }

                sqlCmd.Parameters.Add("@EventTypeName", SqlDbType.VarChar).Value = eventType;
                sqlCmd.Parameters.Add("@ScanLogId", SqlDbType.BigInt).Value = ScanParms.ScanLogKey;
                sqlCmd.Parameters.Add("@TransferServerPairId", SqlDbType.Int).Value = -1;
                sqlCmd.Parameters.Add("@PackageName", SqlDbType.VarChar).Value = taskName;
                sqlCmd.Parameters.Add("@ErrorId", SqlDbType.Int).Value = 1;
                sqlCmd.Parameters.Add("@ErrorDescription", SqlDbType.VarChar).Value = excpetionMessage;
                sqlCmd.Parameters.Add("@SourceName", SqlDbType.VarChar).Value = sourceName;
                sqlCmd.Parameters.Add("@SourceDescription", SqlDbType.VarChar).Value = DBNull.Value;
                sqlCmd.Parameters.Add("@PropagateFlag", SqlDbType.Bit).Value = 0;
                sqlCmd.Parameters.Add("@UserName", SqlDbType.VarChar).Value = "TaskScheduler";
                sqlCmd.Parameters.Add("@EventStartDate", SqlDbType.DateTime).Value = DateTime.UtcNow;
                sqlCmd.Parameters.Add("@EventLogDescription", SqlDbType.VarChar).Value = eventMessage;
                sqlCmd.Parameters.Add("@Serverid", SqlDbType.Int).Value = 6; //DataWarehouse Server Key

                id = (Int64)DataAccess.PostDataSqlCommand(sqlCmd, Config.SqlConnectionString, true);
            }
            catch (Exception ex)
            {
                string error = ex.ToString();
                // Log to NextGenTestServices 
                Logger.LogEvent(System.Diagnostics.EventLogEntryType.Error,
                    "Failed Method: LogEvent(string eventType, string sourceName, string eventMessage, string excpetionMessage)",
                    (int)ApplicationEventID.TOFTaskAction,
                    (short)EventCategoryID.Tasks);
            }
            finally
            {
                // Release the managed resource
                if (sqlCmd != null)
                {
                    sqlCmd.Dispose();
                }
            }

            return id;
        }

        /// <summary>
        /// Bulks the copy dynamic column mapping.
        /// </summary>
        /// <param name="dataTable">The data table.</param>
        /// <param name="destinationTable">The destination table.</param>
        /// <returns></returns>
        private bool BulkCopyDynamicColumnMapping(DataTable dataTable, string destinationTable)
        {
            bool result = false;

            try
            {
                // Perform a Bulk copy for gaining better performance
                // We explicitly specify the UseInternalTransaction option in the SqlBulkCopy class constructor to explicitly cause a bulk copy 
                // operation to execute in its own transaction, causing each batch of the bulk copy operation to execute within a separate transaction.
                // Different batches are executed in different transactions so if an error occurs during the bulk copy operation,
                // only the rows in the current batch will be rolled back. All other rows from previous batches will remain in the database.
                using (SqlBulkCopy bulkCopy = new SqlBulkCopy(Config.SqlConnectionString
                    , SqlBulkCopyOptions.UseInternalTransaction))
                {
                    // Dynamic Column Mapping
                    // Must ensure the Local DataTable has the same column names. 
                    // IMPORTANT:  Columns names are case sensitive.
                    foreach (DataColumn col in dataTable.Columns)
                    {
                        bulkCopy.ColumnMappings.Add(col.ColumnName, col.ColumnName);
                    }

                    bulkCopy.BulkCopyTimeout = 8000;
                    bulkCopy.BatchSize = 5000;
                    bulkCopy.DestinationTableName = destinationTable;

                    bulkCopy.WriteToServer(dataTable);
                    //bulkCopy.Close();

                    //// Log to Management database Event Log
                    //LogEvent(EventType.OnInformation.ToString()
                    //    , Path.GetFileNameWithoutExtension(TaskName)
                    //    , "Bulk Insert for: " + destinationTable
                    //    , "");
                }
                result = true;
            }
            catch (Exception ex)
            {
                errorMessage = String.Empty;
                errorMessage = ex.ToString();

                ShowProgress("Error occurred during Bulk Insert: \r\n" + ex.ToString());
                LogEvent(EventType.OnError.ToString()
                    , Path.GetFileNameWithoutExtension(TaskName)
                    , "BulkCopyDynamicColumnMapping() for " + destinationTable
                    , ex.ToString());
            }
            return result;
        }

        #endregion Database Methods

        #region Dispose Methods

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Finalizes an instance of the <see cref="DSTaskTemplate"/> class.
        /// </summary>
        ~ProcessMemorySmatXMLTask()
        {
            // Finalizer calls Dispose(false)
            Dispose(false);
        }

        /// <summary>
        /// Releases unmanaged and - optionally - managed resources.
        /// </summary>
        /// <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
        protected virtual void Dispose(bool disposing)
        {
            if (disposing)
            {
                // free managed resources
                if (Logger != null)
                {
                    Logger.Dispose();
                    Logger = null;
                }
            }
        }

        #endregion Dispose Methods

        #endregion Design Pattern 

        #region Task Process Variables

        #region Database

        /// <summary>
        /// Gets the valid scan parameter.
        /// </summary>
        /// <returns></returns>
        private bool GetValidScanParameter()
        {
            bool result = false;
            string scanTo = String.Empty;
            string maximumTime = GetTofCreateTime();

            if (Config.TimeOffset != 0)
            {
                DateTime dt;
                if (ScanParms.ScanFrom.Length > 0)
                {
                    dt = Convert.ToDateTime(ScanParms.ScanFrom).AddHours(Config.TimeOffset);

                    if (Convert.ToDateTime(maximumTime) >= dt)
                    {
                        scanTo = dt.ToString(Iso8601DateFormatMap);
                    }
                }
                else
                {
                    if (Config.TimeOffset > 0)
                    {
                        Config.TimeOffset = Config.TimeOffset * -1;
                    }

                    ScanParms.ScanFrom = Convert.ToDateTime(maximumTime).AddHours(Config.TimeOffset).ToString(Iso8601DateFormatMap);
                }
            }

            if (scanTo.Length == 0)
            {
                scanTo = maximumTime;
            }

            ScanParms.ScanTo = scanTo;

            ShowProgress("Current Scan From Time: " + ScanParms.ScanFrom, 1);
            ShowProgress("Current Scan To Time: " + ScanParms.ScanTo, 1);

            if (ScanParms.ScanFrom.Length > 0 && ScanParms.ScanTo.Length > 0)
            {
                result = true;
            }

            return result;
        }

        /// <summary>
        /// Gets the tof create time.
        /// </summary>
        /// <returns></returns>
        private string GetTofCreateTime()
        {
            // Note: Not using a 'Using' statement with SqlCommand so we can process any exception caught at the DataLayer
            // The managed resource is disposed of in the finally block.
            // References: https://msdn.microsoft.com/en-us/library/aa355056%28v=vs.110%29.aspx
            // https://msdn.microsoft.com/en-us/library/yh598w02.aspx
            // https://msdn.microsoft.com/en-us/library/ms182334.aspx
            SqlCommand sqlCmd = new SqlCommand();
            string result = String.Empty;

            try
            {
                sqlCmd.CommandType = CommandType.StoredProcedure;

                if (Config.IsProduction)
                {
                    sqlCmd.CommandText = "[NextGenDW].[dbo].[tsk_RemusTofCreateTimeReadByName]";
                }
                else
                {
                    sqlCmd.CommandText = "[NextGenDWLab].[dbo].[tsk_RemusTofCreateTimeReadByName]";
                }

                sqlCmd.Parameters.Clear();
                sqlCmd.Parameters.Add("@TofName", SqlDbType.VarChar).Value = Config.TestOutputFileName;

                DataTable dt = (DataTable)DataAccess.GetDataSqlCommand(sqlCmd, false, Config.SqlConnectionString);

                if (dt.Rows.Count > 0)
                {
                    result = Convert.ToDateTime(dt.Rows[0]["Max_Create_dt"] + "").ToString(Iso8601DateFormatMap);
                }

            }
            catch (Exception ex)
            {
                errorMessage = String.Empty;
                errorMessage = ex.ToString();

                ShowProgress("Failed to read tof create time from database. \r\nError: " + ex.ToString());
                LogEvent(EventType.OnError.ToString()
                    , Path.GetFileNameWithoutExtension(TaskName)
                    , "GetTofCreateTime()"
                    , ex.ToString());
            }
            finally
            {
                if (sqlCmd != null)
                {
                    sqlCmd.Dispose();
                }
            }

            return result;
        }

        /// <summary>
        /// Gets the last successful process information.
        /// </summary>
        /// <returns></returns>
        private bool GetLastSuccessfulProcessInfo()
        {
            ShowProgress("Getting last successful data process information...", 1);

            // Note: Not using a 'Using' statement with SqlCommand so we can process any exception caught at the DataLayer
            // The managed resource is disposed of in the finally block.
            // References: https://msdn.microsoft.com/en-us/library/aa355056%28v=vs.110%29.aspx
            // https://msdn.microsoft.com/en-us/library/yh598w02.aspx
            // https://msdn.microsoft.com/en-us/library/ms182334.aspx
            SqlCommand sqlCmd = new SqlCommand();
            bool result = false;

            try
            {
                //For Debugging, the TaskName will contain vshost.exe and will not be found. so we check for vshost, and rename.
                string taskName = Path.GetFileNameWithoutExtension(TaskName);
                if (taskName.Contains(".vshost"))
                {
                    taskName = taskName.Replace(".vshost", "");
                }

                // Manual set date range for data processing
                if (Options.ManualDateRangeProcessing)
                {
                    ScanParms.ScanFrom = Options.ManualFromDate;
                    ScanParms.ScanTo = Options.ManualToDate;
                }
                else
                {
                    sqlCmd.CommandType = CommandType.StoredProcedure;

                    if (Config.IsProduction)
                    {
                        sqlCmd.CommandText = "[DataServicesManagement].[dbo].[tsk_GetLastSuccessfulTaskInfo]";
                    }
                    else
                    {
                        sqlCmd.CommandText = "[DataServicesManagementLab].[dbo].[tsk_GetLastSuccessfulTaskInfo]";
                    }

                    sqlCmd.Parameters.Clear();
                    sqlCmd.Parameters.Add("@PackageName", SqlDbType.NVarChar).Value = taskName;
                    sqlCmd.Parameters.Add("@Factory_nm", SqlDbType.NVarChar).Value = "All Factories";
                    //sqlCmd.Parameters.Add("@TransferServerPairKy", SqlDbType.Int).Value = 1;

                    //LogEvent(EventType.OnInformation.ToString()
                    //         , Path.GetFileNameWithoutExtension(taskName)
                    //         , "GetLastSuccessfulProcessInfo()"
                    //         , "");

                    // Log to NextGenTestServices 
                    Logger.LogEvent(System.Diagnostics.EventLogEntryType.Information,
                       TaskName + " task got the last success process information.",
                        (int)ApplicationEventID.TOFTaskAction,
                        (short)EventCategoryID.Tasks);

                    DataTable dt = (DataTable)DataAccess.GetDataSqlCommand(sqlCmd, false, Config.SqlConnectionString);

                    if (dt.Rows.Count > 0)
                    {
                        DataRow row = dt.Rows[0];

                        if ((row["ScanFrom"] + "").Length > 0)
                        {
                            ScanParms.ScanFrom = Convert.ToDateTime(row["ScanFrom"] + "").ToString(Iso8601DateFormatMap);
                        }
                        ShowProgress("Scan From Time: " + ScanParms.ScanFrom, 1);
                    }

                    ShowProgress("Operation was successful.", 1);
                    result = true;
                }
            }
            catch (Exception ex)
            {
                ShowProgress("Failed to read last successful process information. \r\nError: " + ex.ToString());
                // Log to NextGenTestServices 
                Logger.LogEvent(System.Diagnostics.EventLogEntryType.Error,
                   TaskName + " task failed to get the last success process information.",
                    (int)ApplicationEventID.TOFTaskAction,
                    (short)EventCategoryID.Tasks);
                //LogEvent(EventType.OnError.ToString()
                //    , Path.GetFileNameWithoutExtension(TaskName)
                //    , "GetLastSuccessfulProcessInfo()"
                //    , ex.ToString());
            }
            finally
            {
                if (sqlCmd != null)
                {
                    sqlCmd.Dispose();
                }
            }
            return result;
        }

        /// <summary>
        /// Gets the tof file data.
        /// </summary>
        /// <returns></returns>
        private bool GetTofFileData()
        {
            // Note: Not using a 'Using' statement with SqlCommand so we can process any exception caught at the DataLayer
            // The managed resource is disposed of in the finally block.
            // References: https://msdn.microsoft.com/en-us/library/aa355056%28v=vs.110%29.aspx
            // https://msdn.microsoft.com/en-us/library/yh598w02.aspx
            // https://msdn.microsoft.com/en-us/library/ms182334.aspx
            SqlCommand sqlCmd = new SqlCommand();
            bool result = false;

            try
            {
                TestOutputFiles.Clear();

                sqlCmd.CommandType = CommandType.StoredProcedure;
                if (Config.IsProduction)
                {
                    sqlCmd.CommandText = "[NextGenDW].[dbo].[tsk_RemusFactoryTofDataReadByFileName]";
                }
                else
                {
                    sqlCmd.CommandText = "[NextGenDWLab].[dbo].[tsk_RemusFactoryTofDataReadByFileName]";
                }

                sqlCmd.Parameters.Clear();
                sqlCmd.Parameters.Add("@FromDate", SqlDbType.DateTime).Value = ScanParms.ScanFrom;
                sqlCmd.Parameters.Add("@ToDate", SqlDbType.DateTime).Value = ScanParms.ScanTo;
                sqlCmd.Parameters.Add("@TofName", SqlDbType.NVarChar).Value = Config.TestOutputFileName;

                TestOutputFiles = (DataTable)DataAccess.GetDataSqlCommand(sqlCmd, false, Config.SqlConnectionString);

                if (TestOutputFiles.Rows.Count > 0)
                {
                    result = true;
                }
            }
            catch (Exception ex)
            {
                ShowProgress("Failed to read ReMUS TOF file data. \r\nError: " + ex.ToString(), 1);
                LogEvent(EventType.OnError.ToString()
                    , Path.GetFileNameWithoutExtension(TaskName)
                    , "GetTofFileData()"
                    , ex.ToString());
            }
            finally
            {
                if (sqlCmd != null)
                {
                    sqlCmd.Dispose();
                }
                if (TestOutputFiles != null) { TestOutputFiles.Dispose(); }
            }
            return result;
        }

        #region Table

        private DataTable RequiredLocalTable = new DataTable();

        private void PrepLocalTable()
        {
            RequiredLocalTable.Columns.Clear();
            RequiredLocalTable.Columns.Add("Product_ky", typeof(Int64));
            RequiredLocalTable.Columns.Add("MemorySmartPprXMLTOF_ky", typeof(long));
            RequiredLocalTable.Columns.Add("Geography_ky", typeof(int));
            RequiredLocalTable.Columns.Add("Index_at", typeof(int));
            RequiredLocalTable.Columns.Add("Name_at", typeof(string));
            RequiredLocalTable.Columns.Add("Value_at", typeof(string));
            //RequiredLocalTable.Columns.Add("Source_Create_dt", typeof(DateTime));
            RequiredLocalTable.Columns.Add("scan_log_ky", typeof(Int64));
        }

        #endregion Table

        private bool InsertXmlCPuData(List<TOFdataObject> xmlData)
        {
            RequiredLocalTable.Clear();
            bool result = false;

            foreach (TOFdataObject fdo in xmlData)
            {
                DataRow row = RequiredLocalTable.NewRow();
                row["Product_ky"] = fdo.Product;
                row["MemorySmartPprXMLTOF_ky"] = fdo.ParentKey;
                row["Geography_ky"] = fdo.GeographyKey;
                row["Index_at"] = fdo.DeviceNumber;
                row["Name_at"] = fdo.Name;
                row["Value_at"] = fdo.Value;
                //row["Source_Create_dt"] = fdo.SouceCreateTime;
                row["scan_log_ky"] = ScanParms.ScanLogKey;
                RequiredLocalTable.Rows.Add(row);
            }

            if (RequiredLocalTable.Rows.Count > 0)
            {
                if (Config.IsProduction)
                {
                    result = BulkCopyDynamicColumnMapping(RequiredLocalTable, "[NextGenTOF].[TOF].[MemorySmartPprXMLTOF_Processors]");
                }
                else
                {
                    result = BulkCopyDynamicColumnMapping(RequiredLocalTable, "[NextGenTOFLab].[TOF].[MemorySmartPprXMLTOF_Processors]");
                }

            }

            return result;
        }
        private bool InsertXmlData(List<TOFdataObject> xmlData)
        {
            RequiredLocalTable.Clear();
            bool result = false;

            foreach (TOFdataObject fdo in xmlData)
            {
                DataRow row = RequiredLocalTable.NewRow();
                row["Product_ky"] = fdo.Product;
                row["MemorySmartPprXMLTOF_ky"] = fdo.ParentKey;
                row["Geography_ky"] = fdo.GeographyKey;
                row["Index_at"] = fdo.DeviceNumber;
                row["Name_at"] = fdo.Name;
                 row["Value_at"] = fdo.Value;           
                //row["Source_Create_dt"] = fdo.SouceCreateTime;
                row["scan_log_ky"] = ScanParms.ScanLogKey;
                RequiredLocalTable.Rows.Add(row);
            }

            if (RequiredLocalTable.Rows.Count > 0)
            {
                if (Config.IsProduction)
                {
                    result = BulkCopyDynamicColumnMapping(RequiredLocalTable, "[NextGenTOF].[TOF].[MemorySmartPprXMLTOF_Dimms]");
                }
                else
                {
                    result = BulkCopyDynamicColumnMapping(RequiredLocalTable, "[NextGenTOFLab].[TOF].[MemorySmartPprXMLTOFDimms]");
                }

            }
       
            return result;
        }

        #endregion Database

        #region File

        private bool ProcessMemorySmartPprXML()
        {
            bool result = false;
            return result;
        }
        /// <summary>
        /// Processes the MemorySmartPprXMLF file.
        /// </summary>
        /// <param name="data">The data.</param>
        /// <param name="productKey">The product instance key.</param>
        /// <param name="geographyKey">The geography key.</param>
        /// <param name="sourceCreateTime">The source create time.</param>
        /// <returns></returns>

        private bool ProcessMemorySmartPprXMLFile(string data, long productKey, int geographyKey, string sourceCreateTime, long xmlKey)
        {
            bool result = false;

            try
            {
                XDocument xDoc = XDocument.Parse(data);
         
                var processorElement = xDoc.Descendants().Where(e => e.Name.LocalName.ToLowerInvariant() == "processors");
                var elements = xDoc.Descendants().Where(e => e.Name.LocalName.ToLowerInvariant() == "dimm");
                
                //Process Dimm Sections
                if (elements.Count() > 0)
                {
                    int index = 0;
                    foreach (var el in elements)
                    {
                        index = index + 1;
                        if (el.HasElements)                       
                        {
                            foreach (var e in el.Elements())
                           {
                                if (e.Value.Length > 0)
                                {
                                    string MasterName = el.Name.LocalName;
                                    string name = e.Name.LocalName;
                                    string value_at = e.Value;                              
                                    string number = index.ToString();
                                    long parentKey = xmlKey;
                                    TOFdataObject fdo = new TOFdataObject(productKey, geographyKey, number, name, value_at, parentKey);
                                    xmlDataList.Add(fdo);
                                }                         
                          }
                        }
                    }

                    if (xmlDataList.Count > 0)
                    {
                        PrepLocalTable();

                        if (InsertXmlData(xmlDataList))
                        {
                            xmlDataList.Clear();
                            //result = true;
                        }
                    }
                }
                ///  process CPU area ////
                if (processorElement.Count() > 0)
                {
                    int index = 0;
                    foreach (var el in processorElement)
                    {
                        
                        if (el.HasElements)

                        {
                            foreach (var e in el.Elements())
                                
                            {
                                index = index + 1;
                                if (e.Value.Length > 0)
                                {
                                    string MasterName = e.Name.LocalName;
                                    string name = e.Name.LocalName;
                                    string value_at = e.Value;
                                    string number = index.ToString();
                                    long parentKey = xmlKey;
                                    TOFdataObject fdo = new TOFdataObject(productKey, geographyKey, number, name, value_at, parentKey);
                                    xmlDataList.Add(fdo);
                                }
                        }
                    }
                    }

                    if (xmlDataList.Count > 0)
                    {
                        PrepLocalTable();

                        if (InsertXmlCPuData(xmlDataList))
                        {
                            xmlDataList.Clear();
                            result = true;
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                errorMessage = String.Empty;
                errorMessage = ex.ToString();

                ShowProgress("Failed to process MemorySmartPprXml data file. \r\nError: " + ex.ToString(), 1);
                LogEvent(EventType.OnError.ToString()
                    , Path.GetFileNameWithoutExtension(TaskName)
                    , "ProcessMemorySmartPprXmlFile()"
                    , ex.ToString());
            }
            return result;
        }

        /// <summary>
        /// Processes the test output file.
        /// </summary>
        /// <param name="row">The row.</param>
        /// <param name="client">The client.</param>
        /// <returns></returns>
        private bool ProcessTestOutputFile(DataRow row, LinuxSftpClient client)
        {
            bool result = false;

            try
            {
                string fileContent = String.Empty;
                long sourceFileSize = 0;
                string factoryName = (row["Factory_nm"] + "");
                string factoryAliasName = factoryName.Replace(" ", "-");
                string productID = row["ProductID_at"] + "";
                string serialNumber = row["Serial_Number_at"] + "";
                string workObject = row["Work_Object_at"] + "";
                string orderNumber = row["Order_Number_at"] + "";
                string memberID = row["Member_id"] + "";
                string factoryFileName = row["Factory_File_nm"] + "";
                string regionFileName = row["Region_File_nm"] + "";
                string productInstanceKey = row["Product_Instance_ky"] + "";
                string geographyKey = row["Geography_ky"] + "";
                string sourceCreateTime = Convert.ToDateTime(row["Source_Create_dt"]).ToString(Iso8601DateFormatMap);
                string path = GetAbsolutePath(Config.SourceWorkDirectory) + factoryAliasName +
                            @"/" + productID + @"/" + serialNumber + @"/" + regionFileName;

                ShowProgress("-- Current Region File Name: " + regionFileName, 1);

                TofObject tof = new TofObject(factoryName, productID, serialNumber,
                workObject, orderNumber, factoryFileName, regionFileName, Convert.ToInt32(memberID));

                ProductObject product = ReadProductData(tof);
                tof.FileName = product.FileName;

                using (MemoryStream outStream = new MemoryStream())
                {
                    client.DownloadFile(outStream, path);
                    sourceFileSize = client.GetFileSize(path);

                    long downloadSize = outStream.Length;

                    if (downloadSize == sourceFileSize)
                    {
                        using (var archive = new ZipArchive(outStream, ZipArchiveMode.Read))
                        {
                            foreach (var entry in archive.Entries)
                            {
                                if (entry.Name.ToLowerInvariant() == "memorysmartppr.zip")
                                {
                                    using (ZipArchive subArchive = new ZipArchive(entry.Open(), ZipArchiveMode.Read))
                                    {
                                        foreach (var e in subArchive.Entries)
                                        {
                                            if (e.Name.ToLowerInvariant() == "memorysmartppr.xml")
                                            {
                                                using (Stream content = e.Open())
                                                {
                                                    StreamReader sr = new StreamReader(content);
                                                    fileContent = sr.ReadToEnd();
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }


                long MemorySmartPprXML_Ky = CreateParentRecord(product, sourceCreateTime);
                if (fileContent.Length > 0 & MemorySmartPprXML_Ky > 0)
                {
                    result = ProcessMemorySmartPprXMLFile(fileContent, product.ProductKey, product.GeographyKey, sourceCreateTime, MemorySmartPprXML_Ky);
                }
                else
                {

                    if (fileContent.Length == 0)
                    {
                        errorMessage = String.Empty;
                        errorMessage = "MemorySmartPpr.xml file not found in MemorySmartPpr.zip ";
                    }

                }

            }
            catch (Exception ex)
            {
                errorMessage = String.Empty;
                errorMessage = ex.ToString();

                ShowProgress("Failed to process ReMUS test output file. \r\nError: " + ex.ToString(), 1);
                LogEvent(EventType.OnError.ToString()
                    , Path.GetFileNameWithoutExtension(TaskName)
                    , "ProcessTestOutputFile()"
                    , ex.ToString());
            }
            finally {



            }
            return result;
        }

        string errorMessage = String.Empty;

        /// <summary>
        /// Processes the tof reference data.
        /// </summary>
        private void ProcessTofReferenceData()
        {
            bool isProcessSuccessful = false;

            try
            {
                if (GetLastSuccessfulProcessInfo())
                {
                    if (GetValidScanParameter())
                    {
                        CreateScanLog();
                        ShowProgress("Current ScanLogKey: " + ScanParms.ScanLogKey, 1);

                        if (ScanParms.ScanLogKey > 0)
                        {
                            string errorLogName = GetWindowsAbsolutePath(Config.EventLogPath) + Path.GetFileNameWithoutExtension(TaskName) + "-PROCESS-FAILED-" + ScanParms.ScanLogKey + ".log";
                            ShowProgress("Event Log File Name: " + errorLogName, 1);

                            // If Scan from time equals the latest record create time in [Dim_Test_Output_File] table
                            if (IsStartProcess())
                            {
                                bool isSuccessful = GetTofFileData();

                                int fileFoundCount = 0;
                                int fileUpdateCount = 0;

                                if (isSuccessful)
                                {
                                    LinuxSftpClient client = new LinuxSftpClient(Config.SourceHost, Config.SourcePort, Config.SourceUserName, Config.SourcePassword);
                                    client.Open();

                                    if (client.IsConnected)
                                    {
                                        fileFoundCount = TestOutputFiles.Rows.Count;
                                        ShowProgress("Found " + Config.TestOutputFileName + ", file count: " + fileFoundCount, 1);

                                        foreach (DataRow row in TestOutputFiles.Rows)
                                        {
                                            string regionFileName = row["Region_File_nm"] + "";

                                            if (!ProcessTestOutputFile(row, client))
                                            {
                                                ShowProgress("--Failed Process File: " + regionFileName, 1);
                                                
                                                TofLogEvent(errorMessage, row["Factory_nm"] + "", Config.TestOutputFileName, regionFileName, 1, Convert.ToInt64(row["Product_Instance_ky"] + ""));                                     
                                            }
                                            else
                                            {
                                                fileUpdateCount = fileUpdateCount + 1;
                                            }
                                        }
                                    }
                                    client.Close();
                               

                                    if (!isProcessSuccessful)
                                    {
                                        if (fileUpdateCount > 0)
                                        {
                                            UpdateScanLog(TaskName + " task has completed. File found: " + fileFoundCount + ", File processed: " + fileUpdateCount, true);
                                        }
                                        else
                                        {
                                            UpdateScanLog("No data processed.", true);
                                        }
                                    }
                                    else
                                    {
                                        UpdateScanLog("Failed to process Remus commodity file.", false);
                                    }
                                }
                                else
                                {
                                    // No new data record be found
                                    UpdateScanLog("No data processed.", true);
                                }
                            }
                            else
                            {
                                // No new data record be found
                                UpdateScanLog("No data processed.", true);
                            }
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                ShowProgress("Failed to process ReMUS BOM file data. \r\nError: " + ex.ToString(), 1);
                LogEvent(EventType.OnError.ToString()
                    , Path.GetFileNameWithoutExtension(TaskName)
                    , "ProcessTofReferenceData()"
                    , ex.ToString());
            }
        }

        #endregion File

        #region Methods

 
        /// <summary>
        /// Determines whether [is start process].
        /// </summary>
        /// <returns>
        ///   <c>true</c> if [is start process]; otherwise, <c>false</c>.
        /// </returns>
        private bool IsStartProcess()
        {
            bool result = false;

            if (ScanParms.ScanFrom.Length > 0 && ScanParms.ScanTo.Length > 0)
            {
                if (Convert.ToDateTime(ScanParms.ScanFrom) < Convert.ToDateTime(ScanParms.ScanTo))
                {
                    result = true;
                }
            }
            return result;
        }
        private ProductObject ReadProductData(TofObject tof)
        {
            // Note: Not using a 'Using' statement with SqlCommand so we can process any exception caught at the DataLayer
            // The managed resource is disposed of in the finally block.
            // References: https://msdn.microsoft.com/en-us/library/aa355056%28v=vs.110%29.aspx
            // https://msdn.microsoft.com/en-us/library/yh598w02.aspx
            // https://msdn.microsoft.com/en-us/library/ms182334.aspx
            SqlCommand sqlCmd = new SqlCommand();
            ProductObject product = new ProductObject(tof);

            try
            {
                sqlCmd.CommandType = CommandType.StoredProcedure;
                if (Config.IsProduction)
                {
                    sqlCmd.CommandText = "[NextGenTOF].[TOF].[ProcessTOFProduct]";
                }
                else
                {
                    sqlCmd.CommandText = "[NextGenTOFLab].[TOF].[ProcessTOFProduct]";
                }

                sqlCmd.Parameters.Add("@FactoryName", SqlDbType.NVarChar).Value = tof.Factory;
                sqlCmd.Parameters.Add("@ProductID", SqlDbType.NVarChar).Value = tof.ProductID;
                sqlCmd.Parameters.Add("@SerialNumber", SqlDbType.NVarChar).Value = tof.SerialNumber;
                sqlCmd.Parameters.Add("@OrderNumber", SqlDbType.NVarChar).Value = tof.OrderNumber;
                sqlCmd.Parameters.Add("@MemberID", SqlDbType.Int).Value = tof.MemberID;
                sqlCmd.Parameters.Add("@ScanLogKey", SqlDbType.BigInt).Value = ScanParms.ScanLogKey;
                sqlCmd.Parameters.Add("@TestSystem", SqlDbType.NVarChar).Value = "Remus";
                sqlCmd.Parameters.Add("@IsFactoryAliasName", SqlDbType.Bit).Value = 1;

                DataTable dt = (DataTable)DataAccess.GetDataSqlCommand(sqlCmd, false, Config.SqlConnectionString);

                if (dt.Rows.Count > 0)
                {
                    DataRow row = dt.Rows[0];
                    product.ProductKey = Convert.ToInt64(row["Product_ky"]);
                    product.GeographyKey = Convert.ToInt32(row["Geography_ky"]);

                    product.FileName = product.GeographyKey + "_" + product.MemberID + "_" +
                        product.ProductID + "_" + product.SerialNumber + "_" + product.OrderNumber + "_" +
                        Guid.NewGuid().ToString().ToLower() + "_" + product.FileName.Replace(" ", "");
                }
            }
            catch (Exception ex)
            {
                ShowProgress("Failed to read product information. \r\nError: " + ex.ToString(), 1);
                LogEvent(EventType.OnError.ToString()
                    , Path.GetFileNameWithoutExtension(TaskName)
                    , "ReadProductData()"
                    , ex.ToString());
            }
            return product;
        }
        private long CreateParentRecord(ProductObject product, string sourceCreate)
        {
            // Note: Not using a 'Using' statement with SqlCommand so we can process any exception caught at the DataLayer
            // The managed resource is disposed of in the finally block.
            // References: https://msdn.microsoft.com/en-us/library/aa355056%28v=vs.110%29.aspx
            // https://msdn.microsoft.com/en-us/library/yh598w02.aspx
            // https://msdn.microsoft.com/en-us/library/ms182334.aspx
            SqlCommand sqlCmd = new SqlCommand();
            long result = 0;

            try
            {
                sqlCmd.CommandType = CommandType.StoredProcedure;
                if (Config.IsProduction)
                {
                    sqlCmd.CommandText = "[NextGenTOF].[TOF].[tsk_CreateMemorySmartPprXMLTOF]";
                }
                else
                {
                    sqlCmd.CommandText = "[NextGenTOFLab].[TOF].[tsk_CreateMemorySmartPprXMLTOF]";
                }

                sqlCmd.Parameters.Clear();
                sqlCmd.Parameters.Add("@ProductKey", SqlDbType.BigInt).Value = product.ProductKey;
                sqlCmd.Parameters.Add("@GeographyKey", SqlDbType.BigInt).Value = product.GeographyKey;
                sqlCmd.Parameters.Add("@MemberID", SqlDbType.Int).Value = product.MemberID;
                sqlCmd.Parameters.Add("@TestSystemKey", SqlDbType.Int).Value = 1;
                sqlCmd.Parameters.Add("@FileName", SqlDbType.NVarChar).Value = product.FileName;
                sqlCmd.Parameters.Add("@RegionFileName", SqlDbType.NVarChar).Value = product.RegionFileName;
                sqlCmd.Parameters.Add("@ScanLogKey", SqlDbType.BigInt).Value = ScanParms.ScanLogKey;
                sqlCmd.Parameters.Add("Born_dt", SqlDbType.DateTime2).Value =  Convert.ToDateTime(sourceCreate);

                result = (Int64)DataAccess.PostDataSqlCommand(sqlCmd, Config.SqlConnectionString, true);

            }
            catch (Exception ex)
            {
                errorMessage = String.Empty;
                errorMessage = ex.ToString();

                ShowProgress("Failed to create MemorySmartPprXML file record. \r\nError: " + ex.ToString(), 1);
                LogEvent(EventType.OnError.ToString()
                    , Path.GetFileNameWithoutExtension(TaskName)
                    , "CreateParentRecord()"
                    , ex.ToString());
            }
            finally
            {
                if (sqlCmd != null)
                {
                    sqlCmd.Dispose();
                }
            }
            return result;
        }
        /// <summary>
        /// Gets the regex result.
        /// </summary>
        /// <param name="input">The input.</param>
        /// <param name="pattern">The pattern.</param>
        /// <returns></returns>
        private string GetRegexResult(string input, string pattern)
        {
            string result = String.Empty;

            return Regex.IsMatch(input, pattern) ? Regex.Match(input, pattern).Value : result;
        }

        /// <summary>
        /// Gets the absolute path.
        /// </summary>
        /// <param name="path">The path.</param>
        /// <returns></returns>
        private string GetAbsolutePath(string path)
        {
            string result = String.Empty;

            if (!path.EndsWith("/"))
            {
                result = path + "/";
            }
            else
            {
                result = path;
            }

            return result;
        }

        /// <summary>
        /// Gets the windows absolute path.
        /// </summary>
        /// <param name="path">The path.</param>
        /// <returns></returns>
        private string GetWindowsAbsolutePath(string path)
        {
            string result = String.Empty;
            if (!path.EndsWith("\\"))
            {
                result = path + "\\";
            }
            else
            {
                result = path;
            }
            return result;
        }

        #endregion Methods

        #endregion Task Process Variables

    }
}